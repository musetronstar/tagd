// Test suites

#include <cxxtest/TestSuite.h>

#include "tagd.h"
#include "tagdb/sqlite.h"

//const std::string db_fname = "tagdb.sqlite";
const std::string db_fname = ":memory:";

// TODO we may wish to define this in a config.h
// generated by the Makefile, so that these tests
// can be used by other tagdb implementation
typedef tagdb::sqlite tagdb_type;

// populate tags
// return the number of referents inserted
size_t populate_tags(tagdb_type& tdb) {
	size_t num_referents = 0;

    tdb.put( tagd::tag("substance", HARD_TAG_ENTITY) );
    tdb.put( tagd::tag("physical_object", HARD_TAG_ENTITY) );
    tdb.put( tagd::tag("living_thing", "physical_object") );
    // TODO change plural referents when referents in place
    tdb.put( tagd::tag("body_part","physical_object") );
    tdb.put( tagd::tag("teeth","body_part") );  // plural referent => tooth, for now, what the hell
    tdb.put( tagd::tag("fangs","teeth") );
    tdb.put( tagd::tag("fur","body_part") );
    tdb.put( tagd::tag("tail","body_part") );
    tdb.put( tagd::tag("legs","body_part") );  // plural referent
    tdb.put( tagd::tag("beak","body_part") );
    tdb.put( tagd::tag("wings","body_part") );  // plural referent
    tdb.put( tagd::tag("feathers","body_part") );  // plural referent
    tdb.put( tagd::tag("fins","body_part") );  // plural referent

	tdb.put( tagd::tag("machine", "physical_object") );
	tdb.put( tagd::tag("computer", "machine") );

    tdb.put( tagd::tag("mind", HARD_TAG_ENTITY) );

    tdb.put( tagd::tag("communication", HARD_TAG_ENTITY) );
    tdb.put( tagd::tag("language", "communication") );
	tdb.put( tagd::tag("instruction", "language") );
	tdb.put( tagd::tag("program", "instruction") );

    tdb.put( tagd::tag("knowledge", "mind") );
    tdb.put( tagd::tag("concept", "knowledge") );
    tdb.put( tagd::tag("science", "knowledge") );
	tdb.put( tagd::tag("computer_security", "science") );

	tdb.put( tagd::tag("creativity", "mind") );
	tdb.put( tagd::tag("art", "creativity") );
	tdb.put( tagd::tag("visual_art", "art") );
	tdb.put( tagd::tag("movie", "visual_art") );
	tdb.put( tagd::tag("tv_show", "visual_art") );

    tdb.put( tagd::tag("event",HARD_TAG_ENTITY) );
    tdb.put( tagd::tag("sound","event") );
    tdb.put( tagd::tag("action","event") );
    tdb.put( tagd::tag("utterance","sound") );
    tdb.put( tagd::tag("bark","utterance") );
    tdb.put( tagd::tag("meow","utterance") );
    // TODO these are verbs, how do we deal with them?
    tdb.put( tagd::tag("movement","action") );  // to_move
    tdb.put( tagd::tag("fly","movement") );    // to_fly
    tdb.put( tagd::tag("swim","movement") );    // to_swim

    tdb.put( tagd::relator("verb","_rel") );
    tdb.put( tagd::relator("can","verb") );  // no hard_tagd == _can, so no referent
    tdb.put( tagd::relator("preposition","_rel") );
    tdb.put( tagd::relator("about","preposition") );

    tdb.put( tagd::referent("is_a","_is_a") );
	num_referents++;
    tdb.put( tagd::referent("has","_has") );
	num_referents++;

    tdb.put( tagd::tag("body_fluid", "substance") );
    tdb.put( tagd::tag("blood", "body_fluid") );
    tdb.put( tagd::tag("animal", "living_thing") );
    tdb.put( tagd::tag("vertibrate", "animal") );

    tagd::tag mammal("mammal","vertibrate");
    mammal.relation("has", "blood", "warm");
    mammal.relation("has", "teeth");
    tdb.put(mammal);

    tdb.put( tagd::tag("reptile","vertibrate") );
    tdb.put( tagd::tag("invertebrate","animal") );
    tdb.put( tagd::tag("arthropod","invertebrate") );
    tdb.put( tagd::tag("insect","arthropod") );

    tagd::tag dog("dog", "mammal");
    dog.relation("has", "legs", "4");
    dog.relation("has", "tail");
    dog.relation("can", "bark");
    tdb.put(dog);

    tagd::tag cat("cat", "mammal");
    cat.relation("has", "legs", "4");
    cat.relation("has", "tail");
    cat.relation("can", "meow");
    tdb.put(cat);

    tagd::tag whale("whale", "mammal");
    whale.relation("has", "fins");
    whale.relation("can", "swim");
    tdb.put(whale);

    tagd::tag bat("bat", "mammal");
    bat.relation("has", "wings");
    bat.relation("can", "fly");
    tdb.put(bat);

    tagd::tag bird("bird", "vertibrate");
    bird.relation("has", "wings");
    bird.relation("has", "feathers");
    bird.relation("can", "fly");
    tdb.put(bird);

    tdb.put( tagd::tag("canary","bird") );

    tagd::tag spider("spider", "insect");
    spider.relation("has", "fangs");
    spider.relation("has", "legs", "8");
    tdb.put(spider);

    tagd::tag snake("snake", "reptile");
    snake.relation("has", "fangs");
    tdb.put(snake);

	return num_referents;
}

bool tag_set_exists(const tagd::tag_set& S, const tagd::id_type& id) {
    for(tagd::tag_set::iterator it = S.begin(); it != S.end(); ++it)
        if (it->id() == id) return true;

    return false;
}

bool tag_set_exists(const tagd::tag_set& S, const tagd::abstract_tag& t) {
    for(tagd::tag_set::iterator it = S.begin(); it != S.end(); ++it)
        if (*it == t) return true;

    return false;
}

#define TAGD_CODE_STRING(c)	std::string(tagd_code_str(c))

class Tester : public CxxTest::TestSuite {
    public:

	void test_hard_tag_pos(void) {
		std::string id(HARD_TAG_ENTITY);
		tagd::part_of_speech pos = tagdb::hard_tag::pos(id);
		TS_ASSERT_EQUALS(pos, tagd::POS_TAG);

		id = "caca";
		pos = tagdb::hard_tag::pos(id);
		TS_ASSERT_EQUALS(pos, tagd::POS_UNKNOWN);
	}

	void test_hard_tag_get(void) {
		std::string id(HARD_TAG_ENTITY);
		tagd::abstract_tag t;
		tagd::code tc = tagdb::hard_tag::get(t, id);
		TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		TS_ASSERT_EQUALS(t.id(), HARD_TAG_ENTITY);
		TS_ASSERT_EQUALS(t.sub_relator(), HARD_TAG_SUB);
		TS_ASSERT_EQUALS(t.super_object(), HARD_TAG_ENTITY);
		TS_ASSERT(t.rank().empty());

		t.clear();
		id = HARD_TAG_IS_A;
		tc = tagdb::hard_tag::get(t, id);
		TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		TS_ASSERT_EQUALS(t.id(), HARD_TAG_IS_A);
		TS_ASSERT_EQUALS(t.sub_relator(), HARD_TAG_SUB);
		TS_ASSERT_EQUALS(t.super_object(), HARD_TAG_SUB);
		TS_ASSERT_EQUALS(t.rank().dotted_str(), "1.1");

		t.clear();
		id = HARD_TAG_HAS;
		tc = tagdb::hard_tag::get(t, id);
		TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		TS_ASSERT_EQUALS(t.id(), HARD_TAG_HAS);
		TS_ASSERT_EQUALS(t.sub_relator(), HARD_TAG_SUB);
		TS_ASSERT_EQUALS(t.super_object(), HARD_TAG_RELATOR);

		t.clear();
		id = "caca";
		tc = tagdb::hard_tag::get(t, id);
		TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TS_NOT_FOUND");
	}

    void test_init(void) {
        tagdb_type tdb;
        tagd::code tc = tdb.init(db_fname);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        tagd::tag t;
        tc = tdb.get(t, HARD_TAG_ENTITY);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
        TS_ASSERT_EQUALS(t.id(), HARD_TAG_ENTITY);
        TS_ASSERT_EQUALS(t.super_object(), HARD_TAG_ENTITY);
    }

    void test_put_get_rank(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        tagd::tag a("physical_object", HARD_TAG_ENTITY);
        tagd::code tc = tdb.put(a);

        tagd::tag b;
        tc = tdb.get(b, "physical_object");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
        TS_ASSERT_EQUALS(b.id(), "physical_object");
        TS_ASSERT_EQUALS(b.super_object(), HARD_TAG_ENTITY);

		std::string r_dotted = b.rank().dotted_str();
		// living_thing will be first child
		r_dotted.append(".1");

        tagd::tag c("living_thing", "physical_object");
        tc = tdb.put(c); // rank not updated
        TS_ASSERT_EQUALS(tc, tagd::TAGD_OK);

        tc = tdb.get(c, c.id());  // get rank
        TS_ASSERT_EQUALS(tc, tagd::TAGD_OK);
		
        TS_ASSERT_EQUALS(c.rank().dotted_str(), r_dotted);
    }

	void test_put_id_equals_super_object(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::tag a("dog", "dog");
        tdb.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TS_MISUSE");
    }

    void test_put_referent(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::referent a("thing", "physical_object");
        tagd::code tc = tdb.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        tc = tdb.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TS_DUPLICATE");

		// same thing cannot refer to different tag in same context
        tagd::referent a1("thing", "animal");
        tdb.put(a1);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TS_DUPLICATE");

        tagd::referent b("doodoo", "caca");  // unknown refers_to
        tc = tdb.put(b);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TS_REFERS_TO_UNK");

        tagd::referent c("pictures", "movie", "oops");  // unknown context
        tc = tdb.put(c);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TS_CONTEXT_UNK");

		tagd::referent d("pictures", "movie", "event");
		tc = tdb.put(d);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

		tagd::tag photography("photography", "visual_art");
		tdb.put(photography);

		// same thing cannot refer to different tag in same context
		tagd::referent d1("pictures", "photography", "event");
		tc = tdb.put(d1);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TS_DUPLICATE");
    }

	void test_put_refers_to_self(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::referent a("thing", "thing");
        tdb.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TS_MISUSE");

        tagd::referent b("dog", "dog");
        tdb.put(b);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TS_MISUSE");
    }

	void test_delete_tag(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::tag a;
        tagd::code tc = tdb.get(a, "dog");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        tagd::tag b("dog");
        tc = tdb.del(b);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        tagd::tag c;
        tc = tdb.get(c, "dog");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TS_NOT_FOUND");
		tdb.clear_errors();

		// delete tag that is a super_object and relations.object
		tc = tdb.del(tagd::tag("teeth"));
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TS_FOREIGN_KEY");
		TS_ASSERT_EQUALS( tdb.errors().size() , 2 );
		auto errs = tdb.errors();
		if (errs.size() == 2) {
			auto it = errs.begin();
			TS_ASSERT( it->related(HARD_TAG_CAUSED_BY, "super_object", "teeth") );
			it++;
			TS_ASSERT( it->related(HARD_TAG_CAUSED_BY, "object", "teeth") );
		}
		tdb.clear_errors();

		// delete failed, so tag still exists
		tagd::tag d;
		tc = tdb.get(d, "teeth");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		tdb.clear_errors();

		// delete tag that is a super_object and has relations
		tc = tdb.del(tagd::tag("mammal"));
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TS_FOREIGN_KEY");

		// delete failed, so tag and relations still exists
		tagd::tag e;
		tc = tdb.get(e, "mammal");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		TS_ASSERT_EQUALS( e.super_object() , "vertibrate" );
		TS_ASSERT( e.related("has", "blood", "warm") );
		TS_ASSERT( e.related("has", "teeth") );
    }

	void test_delete_relations(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::tag a;
        tagd::code tc = tdb.get(a, "dog");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        tagd::tag b("dog");
		b.relation("has", "tail");
		b.relation("can", "bark");
        tc = tdb.del(b);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		tdb.clear_errors();

        tagd::tag c;
        tc = tdb.get(c, "dog");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		TS_ASSERT( c.related("has", "legs", "4") )
		TS_ASSERT( !c.related("has", "tail")  )
		TS_ASSERT( !c.related("can", "bark")  )

		// delete relation it doesn't have
		tagd::tag d("dog");
		d.relation("can", "meow");
        tc = tdb.del(d);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TS_NOT_FOUND");
		TS_ASSERT_EQUALS( std::string("cannot delete non-existent relation: dog can meow"), tdb.last_error().message() )
		tdb.clear_errors();

		// delete unknown tag
		tagd::tag e("snarf");
        tc = tdb.del(e);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TS_NOT_FOUND");
    }

	void test_get_referent(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::referent thing("thing", "physical_object");
        tdb.put(thing);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		tagd::tag t;
		tdb.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id(), "thing" )
        TS_ASSERT( t.related(HARD_TAG_REFERS_TO, "physical_object") )
	}

    void test_refers_to(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::referent thing("thing", "physical_object");
        tdb.put(thing);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		tagd::tag t;
		tdb.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id(), "thing" )
        TS_ASSERT( t.related(HARD_TAG_REFERS_TO, "physical_object") )

        tagd::referent thing2("thing", "animal", "living_thing");
        tdb.put(thing2);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		tagd::id_type refers_to;
		tdb.refers_to(refers_to, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( refers_to , "physical_object" )

		refers_to.clear();
		tdb.refers_to(refers_to, "physical_object"); // not a referent
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TS_NOT_FOUND")

		tdb.push_context("living_thing");
		refers_to.clear();
		tdb.refers_to(refers_to, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( refers_to , "animal" )

		tagd::part_of_speech p1 = tdb.pos("animal");
		tagd::part_of_speech p2 = tdb.pos("thing");
		TS_ASSERT_EQUALS ( pos_str(p1) , "POS_TAG" )
		TS_ASSERT_EQUALS ( p1 , p2 )
	}

    void test_ambiguous_referent(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::referent thing1("thing", "physical_object", HARD_TAG_ENTITY);
        tdb.put(thing1);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

        tagd::referent thing2("thing", "animal", "living_thing");
        tdb.put(thing2);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		tagd::tag t;
		tdb.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TS_AMBIGUOUS")

		tdb.push_context("living_thing");
		tdb.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id(), "thing" )
        TS_ASSERT( t.related(HARD_TAG_REFERS_TO, "animal") )
	}

    void test_referent_override(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

		tagd::tag prg("cat_program", "program");
		tdb.put(prg);

        tagd::referent cat("cat", "cat_program", "computer");
        tdb.put(cat);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		tagd::tag t1;
		tdb.get(t1, "cat");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t1.id(), "cat" )
        TS_ASSERT_EQUALS( t1.super_object(), "mammal" )

		tdb.push_context("computer");
		tagd::tag t2;
		tdb.get(t2, "cat");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t2.id(), "cat" )
        TS_ASSERT_EQUALS( t2.super_object(), "program" )
        TS_ASSERT( t2.related(HARD_TAG_REFERS_TO, "cat_program") )

		tdb.push_context("animal");
		tagd::tag t3;
		tdb.get(t3, "cat");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t3.id(), "cat" )
        TS_ASSERT_EQUALS( t3.super_object(), "mammal" )
	}

    void test_query_referents(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        //tdb.init("test.db");
        size_t num_referents = populate_tags(tdb);
        tagd::referent thing_physical_object("thing", "physical_object");
        tdb.put(thing_physical_object);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		tagd::abstract_tag t;
		tdb.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id() , "thing" );
        TS_ASSERT( t.related(HARD_TAG_REFERS_TO, "physical_object") );

        tagd::referent thing_animal("thing", "animal", "living_thing");
        tdb.put(thing_animal);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

        tagd::referent creature("creature", "animal", "living_thing");
        tdb.put(creature);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

        tagd::tag_set S;
		// refers.empty() && refers_to.empty() && context.empty()
		// all referents
        tagd::interrogator q_referent("_what", HARD_TAG_REFERENT);
        S.clear();
        tdb.query(S, q_referent);
		//tagd::print_tags(S);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), (3+num_referents) );
        TS_ASSERT( tag_set_exists(S, thing_physical_object) );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
        TS_ASSERT( tag_set_exists(S, creature) );

		// refers.empty() && refers_to.empty() && !context.empty()
        tagd::interrogator q_context("_what", HARD_TAG_REFERENT);
        q_context.relation(HARD_TAG_CONTEXT, "living_thing");
        S.clear();
        tdb.query(S, q_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
        TS_ASSERT( tag_set_exists(S, creature) );

		// refers.empty() && !refers_to.empty() && context.empty()
        tagd::interrogator q_refers_to("_what", HARD_TAG_REFERENT);
        q_refers_to.relation(HARD_TAG_REFERS_TO, "animal");
        S.clear();
        tdb.query(S, q_refers_to);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
        TS_ASSERT( tag_set_exists(S, creature) );

		// refers.empty() && !refers_to.empty() && !context.empty()
        tagd::interrogator q_refers_to_context("_what", HARD_TAG_REFERENT);
        q_refers_to_context.relation(HARD_TAG_REFERS_TO, "animal");
        q_refers_to_context.relation(HARD_TAG_CONTEXT, "physical_object");
		// living_thing _is_a physical_object
        S.clear();
        tdb.query(S, q_refers_to_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
        TS_ASSERT( tag_set_exists(S, creature) );

		// !refers.empty() && refers_to.empty() && context.empty()
        tagd::interrogator q_refers("_what", HARD_TAG_REFERENT);
        q_refers.relation(HARD_TAG_REFERS, "thing");
        S.clear();
        tdb.query(S, q_refers);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, thing_physical_object) );
        TS_ASSERT( tag_set_exists(S, thing_animal) );

		// !refers.empty() && refers_to.empty() && !context.empty()
        tagd::interrogator q_refers_context("_what", HARD_TAG_REFERENT);
        q_refers_context.relation(HARD_TAG_REFERS, "thing");
        q_refers_context.relation(HARD_TAG_CONTEXT, "physical_object");
        S.clear();
        tdb.query(S, q_refers_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );

		// !refers.empty() && !refers_to.empty() && context.empty()
        tagd::interrogator q_refers_refers_to("_what", HARD_TAG_REFERENT);
        q_refers_refers_to.relation(HARD_TAG_REFERS, "thing");
        q_refers_refers_to.relation(HARD_TAG_REFERS_TO, "animal");
        S.clear();
        tdb.query(S, q_refers_refers_to);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );

		// !refers.empty() && !refers_to.empty() && !context.empty()
        tagd::interrogator q_refers_refers_to_context("_what", HARD_TAG_REFERENT);
        q_refers_refers_to_context.relation(HARD_TAG_REFERS, "thing");
        q_refers_refers_to_context.relation(HARD_TAG_REFERS_TO, "animal");
        q_refers_refers_to_context.relation(HARD_TAG_CONTEXT, "physical_object");
        S.clear();
        tdb.query(S, q_refers_refers_to_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
	}

	void test_context_stack(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::referent thing1("thing", "physical_object");
        tdb.put(thing1);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

        tagd::referent thing2("thing", "animal", "living_thing");
        tdb.put(thing2);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

        tagd::referent thing3("thing", "concept", "knowledge");
        tdb.put(thing3);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		tagd::tag t1;
		tdb.get(t1, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t1.id(), "thing" )
        TS_ASSERT( t1.related(HARD_TAG_REFERS_TO, "physical_object") )

		tdb.push_context("living_thing");
		tagd::tag t2;
		tdb.get(t2, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t2.id(), "thing" )
        TS_ASSERT( t2.related(HARD_TAG_REFERS_TO, "animal") )

		tdb.push_context("mind");  // knowledge is_a mind
		tagd::tag t3;
		tdb.get(t3, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t3.id(), "thing" )
        TS_ASSERT( t3.related(HARD_TAG_REFERS_TO, "concept" ) )

		tdb.pop_context();
		tagd::tag t4;
		tdb.get(t4, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t4.id(), "thing" )
        TS_ASSERT( t4.related(HARD_TAG_REFERS_TO, "animal") )

		tdb.clear_context();
		tagd::tag t5;
		tdb.get(t5, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t5.id(), "thing" )
        TS_ASSERT( t5.related(HARD_TAG_REFERS_TO, "physical_object") )
	}

    void test_utf8_japanese_referent(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

		tagd::tag japanese("japanese", "language");
		tdb.put(japanese);

        tagd::referent jp_dog("イヌ", "dog", "japanese");
        tdb.put(jp_dog);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		tagd::tag d;
		tdb.get(d, "イヌ");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TS_AMBIGUOUS")

		tagd::tag t;
		tdb.push_context("japanese");
		tdb.get(t, "イヌ");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id(), "イヌ" )
        TS_ASSERT( t.related(HARD_TAG_REFERS_TO, "dog") )
	}

	void test_delete_referents(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        //tdb.init("test.db");
        populate_tags(tdb);

        tdb.put( tagd::referent("thing", "physical_object") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

        tdb.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

        tdb.put( tagd::referent("creature", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		// non existant referent
        tdb.del( tagd::referent("snarf", "living_thing") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TS_NOT_FOUND" );

		// refers.empty() && refers_to.empty() && context.empty()
        tdb.del( tagd::referent() );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TS_MISUSE" );

		// refers.empty() && refers_to.empty() && !context.empty()
        tdb.del( tagd::referent("", "", "living_thing") );
        tagd::interrogator q_context("_what", HARD_TAG_REFERENT);
        q_context.relation(HARD_TAG_CONTEXT, "living_thing");
		tagd::tag_set S;
        tdb.query(S, q_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TS_NOT_FOUND" );

		// check that thing physical_object still exists
		tagd::id_type what;
        tdb.refers_to(what, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( what , "physical_object" );

        tdb.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

        tdb.put( tagd::referent("creature", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		// refers.empty() && !refers_to.empty() && context.empty()
		tdb.del( tagd::referent("", "animal", "") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );

		// already deleted - does not exist
		tdb.del( tagd::referent("", "animal", "") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TS_NOT_FOUND" );
		
		tdb.push_context("living_thing");
		what.clear();
		tdb.refers(what, "thing");
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TS_NOT_FOUND" );
		tdb.clear_context();

        tdb.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

        tdb.put( tagd::referent("creature", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		// refers.empty() && !refers_to.empty() && !context.empty()
		tdb.del( tagd::referent("", "animal", "living_thing") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );

        tagd::interrogator q_refers_to_context("_what", HARD_TAG_REFERENT);
        q_refers_to_context.relation(HARD_TAG_REFERS_TO, "animal");
        q_refers_to_context.relation(HARD_TAG_CONTEXT, "living_thing");
        S.clear();
        tdb.query(S, q_refers_to_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TS_NOT_FOUND" );

        tdb.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

        tdb.put( tagd::referent("creature", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		// !refers.empty() && refers_to.empty() && context.empty()
		tdb.del( tagd::referent("thing", "", "") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );

        tagd::interrogator q_refers("_what", HARD_TAG_REFERENT);
        q_refers.relation(HARD_TAG_REFERS, "thing");
        S.clear();
        tdb.query(S, q_refers);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TS_NOT_FOUND" );

		// make sure the other referent to animal still exists
		tdb.push_context("living_thing");
		what.clear();
		tdb.refers(what, "animal");
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( what, "creature" );
		tdb.clear_context();

        tdb.put( tagd::referent("thing", "physical_object") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

        tdb.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		// !refers.empty() && refers_to.empty() && !context.empty()
		tdb.del( tagd::referent("thing", "", "living_thing") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );

        tagd::interrogator q_refers_context("_what", HARD_TAG_REFERENT);
        q_refers_context.relation(HARD_TAG_REFERS, "thing");
        q_refers_context.relation(HARD_TAG_CONTEXT, "living_thing");
        S.clear();
        tdb.query(S, q_refers_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TS_NOT_FOUND" );

		// make sure the other referent to animal still exists
		tdb.push_context("living_thing");
		what.clear();
		tdb.refers(what, "animal");
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( what, "creature" );
		tdb.clear_context();

        tdb.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		// !refers.empty() && !refers_to.empty() && context.empty()
		tdb.del( tagd::referent("thing", "animal") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );

        tagd::interrogator q_refers_refers_to("_what", HARD_TAG_REFERENT);
        q_refers_refers_to.relation(HARD_TAG_REFERS, "thing");
        q_refers_refers_to.relation(HARD_TAG_REFERS_TO, "animal");
        S.clear();
        tdb.query(S, q_refers_refers_to);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TS_NOT_FOUND" );

        tdb.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		// !refers.empty() && !refers_to.empty() && !context.empty()
		tdb.del( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );

		tagd::interrogator q_refers_refers_to_context("_what", HARD_TAG_REFERENT);
        q_refers_refers_to_context.relation(HARD_TAG_REFERS, "thing");
        q_refers_refers_to_context.relation(HARD_TAG_REFERS_TO, "animal");
        q_refers_refers_to_context.relation(HARD_TAG_CONTEXT, "living_thing");
        S.clear();
        tdb.query(S, q_refers_refers_to_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TS_NOT_FOUND" );

		// make sure other thing exists
		what.clear();
		tdb.refers_to(what, "thing");
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( what, "physical_object" );

		// delete using refers that would delete refers_to
		tdb.del( tagd::tag("thing") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TS_MISUSE" );

		// test referent gets wiped out
		tdb.put( tagd::referent("thingy", "physical_object") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );

		tdb.del( tagd::referent("thingy", "physical_object") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TAGD_OK" );

		tagd::abstract_tag t;
		tdb.get(t, "thingy");
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tdb.code()), "TS_NOT_FOUND" );
	}

    void test_exists(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::code tc = tdb.exists("dog");
        TS_ASSERT_EQUALS( tc, tagd::TAGD_OK );

        tc = tdb.exists("unicorn");
        TS_ASSERT_EQUALS( tc, tagd::TS_NOT_FOUND );
    }

    void test_pos(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        //tdb.init("test.db");
        populate_tags(tdb);
		tagd::part_of_speech pos = tdb.pos("dog");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_TAG" )

		pos = tdb.pos("_has");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_RELATOR" )

		pos = tdb.pos("has");  // referent relator
        TS_ASSERT_EQUALS( pos_str(pos), "POS_RELATOR" )

		pos = tdb.pos("_is_a");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_SUB_RELATOR" )

		pos = tdb.pos("is_a");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_SUB_RELATOR" )

		pos = tdb.pos("unicorn");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_UNKNOWN" )

    }

    void test_insert_relations(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::tag a("dog", "mammal");  // existing
        a.relation("has", "teeth");
        a.relation("has", "tail");
        a.relation("has", "legs", "4");
        tagd::code tc = tdb.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        tagd::tag b("robin", "bird");  // non-existing
        b.relation("has", "beak");
        b.relation("has", "wings");
        b.relation("has", "feathers");
        tc = tdb.put(b);
        TS_ASSERT_EQUALS(tc, tagd::TAGD_OK);

		tdb.put( tagd::tag("bite", "action") );
        // already existing, only put relations
        tagd::tag c("dog");
        c.relation("can", "bite");
        tc = tdb.put(c);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

		tagd::tag d;
		tc = tdb.get(d, "dog");
		TS_ASSERT( d.related("has", "legs", "4") )
		TS_ASSERT( d.related("has", "tail")  )
		TS_ASSERT( d.related("can", "bite")  )
    }

    void test_duplicate(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::tag dog("dog", "mammal");
        tagd::code tc = tdb.put(dog); // duplicate tag, no relations
        TS_ASSERT_EQUALS( tc, tagd::TS_DUPLICATE );

        dog.relation("has", "fur");
        tc = tdb.put(dog); // not duplicate, relation was inserted
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        tc = tdb.put(dog); // tag duplicate, relations duplicate
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TS_DUPLICATE" );

		tdb.put( tagd::tag("bite", "action") );
        dog.relation("can", "bite");
        tc = tdb.put(dog); // one duplicate (has tail), one insert (can bite)
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );

		tdb.put(tagd::relator("wags", "movement"));
		dog.relation("wags", "tail");
        tc = tdb.put(dog); // relator makes unique

        tagd::tag a("dog");
        a.relation("has", "tail");
        tc = tdb.put(a);  // existing tag, empty sub, existing relation
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TS_DUPLICATE" );

        a.relation("has", "teeth");
        tc = tdb.put(a);  // existing tag, empty sub, one new relation
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
    }

	void test_ignore_duplicate_rank(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

		tagd::tag dolphin("dolphin", "mammal");
        tagd::code tc = tdb.put(dolphin, tagdb::F_IGNORE_DUPLICATES); // new tag, no relations
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

		tagd::tag t1;
		tc = tdb.get(t1, "dolphin");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		tagd::rank r1 = t1.rank();

        tc = tdb.put(dolphin, tagdb::F_IGNORE_DUPLICATES); // duplicate not inserted
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

		tagd::tag t2;
		tc = tdb.get(t2, "dolphin");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		tagd::rank r2 = t2.rank();

        TS_ASSERT_EQUALS(r1.dotted_str(), r2.dotted_str())
    }

    void test_ignore_duplicate(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::tag dog("dog", "mammal");
        tagd::code tc = tdb.put(dog, tagdb::F_IGNORE_DUPLICATES); // duplicate tag, no relations
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        dog.relation("has", "fur");
        tc = tdb.put(dog, tagdb::F_IGNORE_DUPLICATES); // not duplicate, relation was inserted
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        tc = tdb.put(dog, tagdb::F_IGNORE_DUPLICATES); // tag duplicate, relations duplicate
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

		tdb.put( tagd::tag("bite", "action") );
        dog.relation("can", "bite");
        tc = tdb.put(dog, tagdb::F_IGNORE_DUPLICATES); // one duplicate (has tail), one insert (can bite)
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );

		tdb.put(tagd::relator("wags", "movement"));
		dog.relation("wags", "tail");
        tc = tdb.put(dog, tagdb::F_IGNORE_DUPLICATES); // relator makes unique

        tagd::tag a("dog");
        a.relation("has", "tail");
        tc = tdb.put(a, tagdb::F_IGNORE_DUPLICATES);  // existing tag, empty sub, existing relation
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );

        a.relation("has", "teeth");
        tc = tdb.put(a, tagdb::F_IGNORE_DUPLICATES);  // existing tag, empty sub, one new relation
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
    }

    void test_move(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::tag a("sea_creature", "living_thing");
        tagd::code tc = tdb.put(a);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );

        tagd::tag b("fish", "insect");
        tc = tdb.put(b);  // oops
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );

		b.super_object("sea_creature");
        tc = tdb.put(b);  // move
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
		size_t sz = a.rank().dotted_str().size();
		// a rank should prefix b rank
        TS_ASSERT_EQUALS( a.rank().dotted_str(), b.rank().dotted_str().substr(0, sz) )
    }

    void test_move_entity(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        tagd::tag a("animal", HARD_TAG_ENTITY);
        tagd::code tc = tdb.put(a);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );

        tagd::tag b("dog", HARD_TAG_ENTITY);
        tc = tdb.put(b);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );

        tagd::tag c("dog", "animal");
        tc = tdb.put(c);  // move
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
		size_t sz = a.rank().dotted_str().size();
		// a rank should prefix c rank
        TS_ASSERT_EQUALS( a.rank().dotted_str(), c.rank().dotted_str().substr(0, sz) )
    }

    void test_undef_tag_refs(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::tag dog("dog", "nosuchthing");
        tagd::code tc = tdb.put(dog);
        TS_ASSERT_EQUALS( tc, tagd::TS_SUB_UNK );

        dog.super_object("mammal");
        dog.relation("has", "tailandwings");
        tc = tdb.put(dog);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TS_OBJECT_UNK" );

        dog.relations.clear();
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(dog.relation("flobdapperbates", "tail")), "TAGD_OK" );
        tc = tdb.put(dog);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TS_RELATOR_UNK" );

        tagd::tag a("dog");  // existing no sub, no relations
        tc = tdb.put(a);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TS_MISUSE" );
    }

    void test_related(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        //tdb.init("tagdb.sqlite");
        populate_tags(tdb);

		tagd::code tc;
		tagd::tag t;

        tagd::tag_set S;
        tc = tdb.related(S, tagd::predicate("has", "legs")); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 3 );

        S.empty();
        tc = tdb.related(S, tagd::predicate("has", "legs", "3", tagd::OP_GT)); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 3 );

        S.empty();
        tc = tdb.related(S, tagd::predicate("has", "legs", "30", tagd::OP_GT, tagd::TYPE_INTEGER)); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TS_NOT_FOUND" );
        TS_ASSERT_EQUALS( S.size(), 0 );

        S.empty();
        tc = tdb.related(S, tagd::predicate("_rel", "body_part")); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 8 );
        // for(tagd::tag_set::iterator it = S.begin(); it != S.end(); ++it) {
        //    std::cout << *it << std::endl;
        // }

        // TODO test related with existing and not existing subs

        tc = tdb.related(S, tagd::predicate("snarfs", "cockamamy")); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TS_NOT_FOUND" );
        TS_ASSERT_EQUALS( S.size(), 0 );

        S.clear();
        tc = tdb.related(S, tagd::predicate("can", "")); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 5 )
    }

    void test_query(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        // TODO "_what" is not actually used in the query
        // this will change over time, as different types
        // of interrogators will denote different queries
        tagd::interrogator q("_what", "mammal");
        q.relation("can", "swim");

        tagd::tag_set S;
        tagd::code tc = tdb.query(S, q);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, "whale") );

        S.clear();
        tagd::interrogator r("_what");
        r.relation("has", "fangs");
        tc = tdb.query(S, r);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, "spider") );
        TS_ASSERT( tag_set_exists(S, "snake") );

        S.clear();
        tagd::interrogator s("_what");
        s.relation("has", "teeth");
        tc = tdb.query(S, s);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 3 );
        TS_ASSERT( tag_set_exists(S, "mammal") );
        TS_ASSERT( tag_set_exists(S, "spider") );  // fangs are teeth
        TS_ASSERT( tag_set_exists(S, "snake") );

        S.clear();
        tagd::interrogator q1("_what");
        q1.relation("has", "legs", "2", tagd::OP_GT);
        q1.relation("has", "body_part", "8", tagd::OP_LT_EQ);
        tc = tdb.query(S, q1);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 3 );
        TS_ASSERT( tag_set_exists(S, "dog") );
        TS_ASSERT( tag_set_exists(S, "cat") );
        TS_ASSERT( tag_set_exists(S, "spider") );

		int num = 0;
        for(tagd::tag_set::iterator it = S.begin(); it != S.end(); ++it) {
            if (it->id() == "dog") {
				if (it->related("has", "legs", "4")) num++;
			}
			else if (it->id() == "cat") {
				if (it->related("has", "legs", "4")) num++;
			}
			else if (it->id() == "spider") {
				if (it->related("has", "legs", "8")) num++;
			}
        }
		TS_ASSERT_EQUALS( num , 3 )

		S.clear();
        tagd::interrogator q2("_what", "animal");
		q2.relation("has", "");
        q2.relation("can", "");
        tc = tdb.query(S, q2);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 5 );
        TS_ASSERT( tag_set_exists(S, "dog") );
        TS_ASSERT( tag_set_exists(S, "cat") );
        TS_ASSERT( tag_set_exists(S, "whale") );
        TS_ASSERT( tag_set_exists(S, "bat") );
        TS_ASSERT( tag_set_exists(S, "bird") );

		// TODO tagd::merge_containing tags fails to merge predicates
    }

    void test_query_super_object(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        // TODO "_what" is not actually used in the query
        // this will change over time, as different types
        // of interrogators will denote different queries
        tagd::interrogator q("_what", "mammal");

        tagd::tag_set S;
        tagd::code tc = tdb.query(S, q);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 4 );
        TS_ASSERT( tag_set_exists(S, "dog") );
        TS_ASSERT( tag_set_exists(S, "cat") );
        TS_ASSERT( tag_set_exists(S, "whale") );
        TS_ASSERT( tag_set_exists(S, "bat") );
    }

	void test_query_parent_relation(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::interrogator q("_what");
        q.relation("has", "blood", "warm");
        q.relation("can", "swim");

        tagd::tag_set S;
        tagd::code tc = tdb.query(S, q);
		if (!tdb.ok()) {
			tdb.print_errors();
		}
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, "whale") );
	}

	void test_search(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

		// std::cout << std::endl; tdb.dump_search();

		std::string terms = "mammal can swim";
        tagd::tag_set S;
        tagd::code tc = tdb.search(S, terms);
		tdb.print_errors();
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, "whale") );

        S.clear();
        terms = "has fangs";
        tc = tdb.search(S, terms);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, "spider") );
        TS_ASSERT( tag_set_exists(S, "snake") );

        S.clear();
        terms = "has teeth";
        tc = tdb.search(S, terms);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, "mammal") );
		// fangs are teeth, but don't match FTS for teeth
        TS_ASSERT( !tag_set_exists(S, "spider") );
        TS_ASSERT( !tag_set_exists(S, "snake") );

		S.clear();
        terms = "mammal has can";
        tc = tdb.search(S, terms);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 4 );
        TS_ASSERT( tag_set_exists(S, "dog") );
        TS_ASSERT( tag_set_exists(S, "cat") );
        TS_ASSERT( tag_set_exists(S, "whale") );
        TS_ASSERT( tag_set_exists(S, "bat") );
    }

	void test_query_search(void) {
        tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::interrogator q("_what", "mammal");
		q.relation(HARD_TAG_HAS, HARD_TAG_TERMS, "can swim");
        tagd::tag_set S;
        tagd::code tc = tdb.query(S, q);
		tdb.print_errors();
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, "whale") );

        S.clear();
        tagd::interrogator r("_what");
		r.relation(HARD_TAG_HAS, HARD_TAG_TERMS, "has fangs");
        tc = tdb.query(S, r);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, "spider") );
        TS_ASSERT( tag_set_exists(S, "snake") );

        S.clear();
        tagd::interrogator s("_what");
		s.relation(HARD_TAG_HAS, HARD_TAG_TERMS, "has teeth");
        tc = tdb.query(S, s);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, "mammal") );
		// fangs are teeth, but not a FTS match
        TS_ASSERT( !tag_set_exists(S, "spider") );
        TS_ASSERT( !tag_set_exists(S, "snake") );

		S.clear();
        tagd::interrogator q2("_what", "animal");
		q2.relation(HARD_TAG_HAS, HARD_TAG_TERMS, "has can");
        tc = tdb.query(S, q2);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 5 );
        TS_ASSERT( tag_set_exists(S, "dog") );
        TS_ASSERT( tag_set_exists(S, "cat") );
        TS_ASSERT( tag_set_exists(S, "whale") );
        TS_ASSERT( tag_set_exists(S, "bat") );
        TS_ASSERT( tag_set_exists(S, "bird") );

		S.clear();
		tagd::interrogator s1(HARD_TAG_SEARCH);
		s1.relation(HARD_TAG_HAS, HARD_TAG_TERMS, "warm blood");
		s1.relation(HARD_TAG_HAS, HARD_TAG_TERMS, "can bark");
        tc = tdb.query(S, s1);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, "dog") );

		// test update search terms
		tdb.put( tagd::tag("bite", "action") );
        tagd::tag t("dog");
        t.relation("can", "bite");
        tdb.put(t);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK");

		S.clear();
		tagd::interrogator s2(HARD_TAG_SEARCH);
		s2.relation(HARD_TAG_HAS, HARD_TAG_TERMS, "can bite");
        tc = tdb.query(S, s2);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, "dog") );
    }

    void test_get_hard_tag(void) {
		tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::tag t;
        tagd::code tc = tdb.get(t, "_url");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
        TS_ASSERT_EQUALS( t.id(), "_url" )
	}

    void test_put_hard_tag(void) {
		tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::tag t("_caca", HARD_TAG_ENTITY);
        tagd::code tc = tdb.put(t);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TS_MISUSE");
	}

    void test_put_get_tag_sub_relator(void) {
		tagdb_type tdb;
		tdb.init(db_fname);
		populate_tags(tdb);

		tagd::tag t1("husky", HARD_TAG_TYPE_OF, "dog");
		tdb.put(t1);
		TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")

		tagd::abstract_tag t2;
		tdb.get(t2, "husky");
		TS_ASSERT_EQUALS(TAGD_CODE_STRING(tdb.code()), "TAGD_OK")
		TS_ASSERT_EQUALS( t2.sub_relator() , HARD_TAG_TYPE_OF )
	}

    void test_relations(void) {
		tagdb_type tdb;
        tdb.init(db_fname);
        populate_tags(tdb);

        tagd::tag dog;
        tdb.get(dog, "dog");
        TS_ASSERT_EQUALS( dog.relations.size(), 3 )
		TS_ASSERT( dog.related("has", "legs", "4") )
		TS_ASSERT( dog.related("has", "tail")  )

        tagd::predicate_set how;
		TS_ASSERT_EQUALS( dog.related("bark", how), 1 )
		auto it = how.begin();
		TS_ASSERT( it != how.end() );
		if (it != how.end()) {
			TS_ASSERT_EQUALS( it->relator, "can" )
			TS_ASSERT_EQUALS( it->object, "bark" )
		}

		how.clear();
		TS_ASSERT_EQUALS( dog.related("legs", how), 1 )
		it = how.begin();
		TS_ASSERT( it != how.end() );
		if (it != how.end()) {
			TS_ASSERT_EQUALS( it->relator, "has" )
			TS_ASSERT_EQUALS( it->object, "legs" )
			TS_ASSERT_EQUALS( it->modifier, "4" )
		}

		TS_ASSERT( !dog.related("has", "fins") )
	}

/// URI TESTS ///

    void test_put_url(void) {
        tagdb_type tdb;
        tagd::code tc = tdb.init(db_fname);
        //tagd::code tc = tdb.init("test.db");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        populate_tags(tdb);

        tagd::url a("http://www.hypermega.com/a/b/c?x=1&y=2#here");
        a.relation("about", "computer_security");
		TS_ASSERT_EQUALS(a.id(), "http://www.hypermega.com/a/b/c?x=1&y=2#here"); 
        tc = tdb.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		TS_ASSERT_EQUALS(a.id(), "http://www.hypermega.com/a/b/c?x=1&y=2#here"); 

        tagd::url b;
        tc = tdb.get(b, a.id()); 
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		TS_ASSERT_EQUALS(b.id(), "http://www.hypermega.com/a/b/c?x=1&y=2#here"); 
		TS_ASSERT_EQUALS(b.hduri(), "com:hypermega:www:/a/b/c:?x=1&y=2:here:http");
        TS_ASSERT( b.relations.size() > 1 )
        TS_ASSERT( b.related("about", "computer_security") )
        TS_ASSERT( b.related("has", HARD_TAG_SCHEME, "http") )
        TS_ASSERT( b.related("has", HARD_TAG_HOST, "www.hypermega.com") )
        TS_ASSERT( b.related("has", HARD_TAG_PRIV_LABEL, "hypermega") )
        TS_ASSERT( b.related("has", HARD_TAG_PUBLIC, "com") )
        TS_ASSERT( b.related("has", HARD_TAG_SUBDOMAIN, "www") )
        TS_ASSERT( b.related("has", HARD_TAG_PATH, "/a/b/c") )
        TS_ASSERT( b.related("has", HARD_TAG_QUERY, "?x=1&y=2") )
        TS_ASSERT( b.related("has", HARD_TAG_FRAGMENT, "here") )
    }

    void test_get_hduri(void) {
        tagdb_type tdb;
        tagd::code tc = tdb.init(db_fname);
        //tagd::code tc = tdb.init("tagdb.db");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        populate_tags(tdb);

        tagd::url a("http://www.hypermega.com/a/b/c?x=1&y=2#here");
        a.relation("about", "computer_security");
        tc = tdb.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        tagd::abstract_tag b;
        tc = tdb.get(b, a.hduri()); 
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		TS_ASSERT_EQUALS(b.id(), "com:hypermega:www:/a/b/c:?x=1&y=2:here:http");
        TS_ASSERT_EQUALS( b.super_object() , HARD_TAG_URL )
        TS_ASSERT( b.related("about", "computer_security") )
        TS_ASSERT( b.related("has", HARD_TAG_SCHEME, "http") )
        TS_ASSERT( b.related("has", HARD_TAG_HOST, "www.hypermega.com") )
        TS_ASSERT( b.related("has", HARD_TAG_PRIV_LABEL, "hypermega") )
        TS_ASSERT( b.related("has", HARD_TAG_PUBLIC, "com") )
        TS_ASSERT( b.related("has", HARD_TAG_SUBDOMAIN, "www") )
        TS_ASSERT( b.related("has", HARD_TAG_PATH, "/a/b/c") )
        TS_ASSERT( b.related("has", HARD_TAG_QUERY, "?x=1&y=2") )
        TS_ASSERT( b.related("has", HARD_TAG_FRAGMENT, "here") )
    }

    void test_query_url(void) {
        tagdb_type tdb;
		tagd::code tc;
        tdb.init(db_fname);
        // tdb.init("tagdb.sqlite");
        populate_tags(tdb);

        tagd::url a("http://en.wikipedia.org/wiki/Dog");
        a.relation("about", "dog");
        tc = tdb.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

		tagd::tag starwars("starwars", "movie");
		tdb.put(starwars);
        tagd::url b("http://starwars.wikia.com/wiki/Dog");
        b.relation("about", "starwars");
        tc = tdb.put(b);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        tagd::url c("http://animal.discovery.com/tv-shows/dogs-101");
        c.relation("about", "dog");
        tc = tdb.put(c);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

        // TODO "_what" is not actually used in the query
        tagd::interrogator q("_what", "_url");
        q.relation("about", "dog");

        tagd::tag_set S;
        tc = tdb.query(S, q);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, "http://en.wikipedia.org/wiki/Dog") );
        TS_ASSERT( tag_set_exists(S, "http://animal.discovery.com/tv-shows/dogs-101") );

        S.clear();
        tagd::interrogator r("_what", "_url");
        r.relation("has", "_path", "/wiki/Dog");
        tc = tdb.query(S, r);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, "http://en.wikipedia.org/wiki/Dog") );
        TS_ASSERT( tag_set_exists(S, "http://starwars.wikia.com/wiki/Dog") );

        // _what is 'about' something
        tagd::interrogator what_about(HARD_TAG_INTERROGATOR);
        what_about.relation(tagd::predicate("about", ""));

        S.clear();
        tc = tdb.query(S, what_about);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(tc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 3 );
        TS_ASSERT( tag_set_exists(S, "http://en.wikipedia.org/wiki/Dog") );
        TS_ASSERT( tag_set_exists(S, "http://starwars.wikia.com/wiki/Dog") );
        TS_ASSERT( tag_set_exists(S, "http://animal.discovery.com/tv-shows/dogs-101") );
    }

	void test_delete_url(void) {
        tagdb_type tdb;
		tagd::code tc;
        tdb.init(db_fname);
        // tdb.init("tagdb.sqlite");
        populate_tags(tdb);

        tagd::url a("http://en.wikipedia.org/wiki/Dog");
        a.relation("about", "dog");
        tc = tdb.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

		// delete relation
		a.not_relation("about", "dog");
		TS_ASSERT(!a.relation("about", "dog"));
		tc = tdb.del(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

		tagd::url b;
        tc = tdb.get(b, "http://en.wikipedia.org/wiki/Dog");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");
		TS_ASSERT( !b.related("about", "dog") );

		// delete url	
        tagd::url c("http://en.wikipedia.org/wiki/Dog");
		tc = tdb.del(c);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TAGD_OK");

		tagd::url d;
        tc = tdb.get(d, "http://en.wikipedia.org/wiki/Dog");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(tc), "TS_NOT_FOUND");
    }

    void test_util(void) {
		std::string db_file = tagdb::util::user_db();
		TS_ASSERT( !db_file.empty() )
	}

//    void test_dump(void) {
//        tagdb_type tdb;
//        tdb.init(db_fname);
//		std::cout << std::endl;
//        populate_tags(tdb);
//		tdb.dump();
//	}

//	void test_dump_terms(void) {
//        tagdb_type tdb;
//        tdb.init(db_fname);
//		std::cout << std::endl;
//        populate_tags(tdb);
//		tdb.dump_terms();
//	}


};
