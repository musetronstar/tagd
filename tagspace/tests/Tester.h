// Test suites

#include <cxxtest/TestSuite.h>

#include "tagd.h"
#include "tagspace/sqlite.h"

//const std::string db_fname = "tagspace.sqlite";
const std::string db_fname = ":memory:";

// TODO we may wish to define this in a config.h
// generated by the Makefile, so that these tests
// can be used by other tagspace implementation
typedef tagspace::sqlite space_type;

// populate tags minimally so we can test inserting, etc
void populate_tags_minimal(space_type& TS) {
    tagd::tag physical_object("physical_object", "_entity");
    TS.put(physical_object);
    tagd::tag living_thing("living_thing", "physical_object");
    TS.put(living_thing);
    tagd::tag animal("animal", "living_thing");
    TS.put(animal);
    tagd::tag vertibrate("vertibrate", "animal");
    TS.put(vertibrate);
    tagd::tag mammal("mammal","vertibrate");
    TS.put(mammal);
    tagd::tag dog("dog","mammal");
    TS.put(dog);
    tagd::tag cat("cat","mammal");
    TS.put(cat);
    tagd::tag bird("bird","vertibrate");
    TS.put(bird);
    tagd::tag canary("canary","bird");
    TS.put(canary);
    tagd::tag invertebrate("invertebrate","animal");
    TS.put(invertebrate);
    tagd::tag arthropod("arthropod","invertebrate");
    TS.put(arthropod);
    tagd::tag insect("insect","arthropod");
    TS.put(insect);
    tagd::tag n("spider","insect");

    // TODO change plural referents when referents in place
    tagd::tag body_part("body_part","physical_object");
    TS.put(body_part);
    tagd::tag teeth("teeth","body_part");  // plural referent => tooth, for now, what the hell
    TS.put(teeth);
    tagd::tag tail("tail","body_part");
    TS.put(tail);
    tagd::tag legs("legs","body_part");  // plural referent
    TS.put(legs);
    tagd::tag beak("beak","body_part");
    TS.put(beak);
    tagd::tag wings("wings","body_part");  // plural referent
    TS.put(wings);
    tagd::tag feathers("feathers","body_part");  // plural referent
    TS.put(feathers);
    tagd::tag fins("fins","body_part");  // plural referent
    TS.put(fins);

    tagd::tag event("event","_entity");
    TS.put(event);
    tagd::tag sound("sound","event");
    TS.put(sound);
    tagd::tag action("action","event");
    TS.put(action);
    tagd::tag utterance("utterance","sound");
    TS.put(utterance);
    tagd::tag bark("bark","utterance");
    TS.put(bark);
    tagd::tag meow("meow","utterance");
    TS.put(meow);
    // TODO these are verbs, how do we deal with them?
    tagd::tag move("move","action");  // to_move
    TS.put(move);
    tagd::tag fly("fly","move");    // to_fly
    TS.put(fly);
    tagd::tag swim("swim","move");    // to_swim
    TS.put(swim);

    tagd::tag word("word","_relator");
    TS.put(word);
    tagd::tag verb("verb","word");
    TS.put(verb);

    tagd::relator has("has","verb");
    TS.put(has);
    tagd::relator can("can","verb");
    TS.put(can);
}


void populate_tags(space_type& TS) {
    tagd::tag substance("substance", "_entity");
    TS.put(substance);
    tagd::tag physical_object("physical_object", "_entity");
    TS.put(physical_object);
    tagd::tag living_thing("living_thing", "physical_object");
    TS.put(living_thing);
    // TODO change plural referents when referents in place
    tagd::tag body_part("body_part","physical_object");
    TS.put(body_part);
    tagd::tag teeth("teeth","body_part");  // plural referent => tooth, for now, what the hell
    TS.put(teeth);
    tagd::tag fangs("fangs","teeth");
    TS.put(fangs);
    tagd::tag tail("tail","body_part");
    TS.put(tail);
    tagd::tag legs("legs","body_part");  // plural referent
    TS.put(legs);
    tagd::tag beak("beak","body_part");
    TS.put(beak);
    tagd::tag wings("wings","body_part");  // plural referent
    TS.put(wings);
    tagd::tag feathers("feathers","body_part");  // plural referent
    TS.put(feathers);
    tagd::tag fins("fins","body_part");  // plural referent
    TS.put(fins);

	tagd::tag machine("machine", "physical_object");
	TS.put(machine);
	tagd::tag computer("computer", "machine");
	TS.put(computer);

    tagd::tag mind("mind", "_entity");
    TS.put(mind);

    tagd::tag communication("communication", "_entity");
    TS.put(communication);
    tagd::tag language("language", "communication");
    TS.put(language);
	tagd::tag instruction("instruction", "language");
	TS.put(instruction);
	tagd::tag prg("program", "instruction");
	TS.put(prg);

    tagd::tag knowledge("knowledge", "mind");
    TS.put(knowledge);
    tagd::tag concept("concept", "knowledge");
    TS.put(concept);
    tagd::tag science("science", "knowledge");
    TS.put(science);
	tagd::tag cs("computer_security", "science");
	TS.put(cs);

	tagd::tag creativity("creativity", "mind");
	TS.put(creativity);
	tagd::tag art("art", "creativity");
	TS.put(art);
	tagd::tag visual_art("visual_art", "art");
	TS.put(visual_art);
	tagd::tag movie("movie", "visual_art");
	TS.put(movie);
	tagd::tag tv_show("tv_show", "visual_art");
	TS.put(tv_show);

    tagd::tag event("event","_entity");
    TS.put(event);
    tagd::tag sound("sound","event");
    TS.put(sound);
    tagd::tag action("action","event");
    TS.put(action);
    tagd::tag utterance("utterance","sound");
    TS.put(utterance);
    tagd::tag bark("bark","utterance");
    TS.put(bark);
    tagd::tag meow("meow","utterance");
    TS.put(meow);
    // TODO these are verbs, how do we deal with them?
    tagd::tag move("move","action");  // to_move
    TS.put(move);
    tagd::tag fly("fly","move");    // to_fly
    TS.put(fly);
    tagd::tag swim("swim","move");    // to_swim
    TS.put(swim);

    tagd::tag word("word","_relator");
    TS.put(word);
    tagd::tag verb("verb","word");
    TS.put(verb);
    tagd::tag preposition("preposition","word");
    TS.put(preposition);

    tagd::relator has("has","verb");
    TS.put(has);
    tagd::relator can("can","verb");
    TS.put(can);
    tagd::relator about("about","preposition");
    TS.put(about);

    tagd::tag body_fluid("body_fluid", "substance");
    TS.put(body_fluid);
    tagd::tag blood("blood", "body_fluid");
    TS.put(blood);
    tagd::tag animal("animal", "living_thing");
    TS.put(animal);
    tagd::tag vertibrate("vertibrate", "animal");
    TS.put(vertibrate);

    tagd::tag mammal("mammal","vertibrate");
    mammal.relation("has", "blood", "warm");
    mammal.relation("has", "teeth");
    TS.put(mammal);

    tagd::tag reptile("reptile","vertibrate");
    TS.put(reptile);
    tagd::tag invertebrate("invertebrate","animal");
    TS.put(invertebrate);
    tagd::tag arthropod("arthropod","invertebrate");
    TS.put(arthropod);
    tagd::tag insect("insect","arthropod");
    TS.put(insect);
    tagd::tag n("spider","insect");

    tagd::tag dog("dog", "mammal");
    dog.relation("has", "legs", "4");
    dog.relation("has", "tail");
    dog.relation("can", "bark");
    TS.put(dog);

    tagd::tag cat("cat", "mammal");
    cat.relation("has", "legs", "4");
    cat.relation("has", "tail");
    cat.relation("can", "meow");
    TS.put(cat);

    tagd::tag whale("whale", "mammal");
    whale.relation("has", "fins");
    whale.relation("can", "swim");
    TS.put(whale);

    tagd::tag bat("bat", "mammal");
    bat.relation("has", "wings");
    bat.relation("can", "fly");
    TS.put(bat);

    tagd::tag bird("bird", "vertibrate");
    bird.relation("has", "wings");
    bird.relation("has", "feathers");
    bird.relation("can", "fly");
    TS.put(bird);

    tagd::tag canary("canary","bird");
    TS.put(canary);

    tagd::tag spider("spider", "insect");
    spider.relation("has", "fangs");
    TS.put(spider);

    tagd::tag snake("snake", "reptile");
    snake.relation("has", "fangs");
    TS.put(snake);
}

bool tag_set_exists(const tagd::tag_set& S, const tagd::id_type& id) {
    for(tagd::tag_set::iterator it = S.begin(); it != S.end(); ++it)
        if (it->id() == id) return true;

    return false;
}

bool tag_set_exists(const tagd::tag_set& S, const tagd::abstract_tag& t) {
    for(tagd::tag_set::iterator it = S.begin(); it != S.end(); ++it)
        if (*it == t) return true;

    return false;
}

#define TAGD_CODE_STRING(c)	std::string(tagd_code_str(c))

class Tester : public CxxTest::TestSuite {
    public:

    void test_init(void) {
        space_type TS;
        //tagd_code ts_rc = TS.init(db_fname);
        tagd_code ts_rc = TS.init("test.db");
		TS.print_errors();
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        tagd::tag t;
        ts_rc = TS.get(t, "_entity");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
        TS_ASSERT_EQUALS(t.id(), "_entity");
        TS_ASSERT_EQUALS(t.super(), "_entity");
    }

    void test_put_get_rank(void) {
        space_type TS;
        TS.init(db_fname);

        tagd::tag a("physical_object", "_entity");
        tagd_code ts_rc = TS.put(a);

        tagd::tag b;
        ts_rc = TS.get(b, "physical_object");
        TS_ASSERT_EQUALS(ts_rc, tagd::TAGD_OK);
        TS_ASSERT_EQUALS(b.id(), "physical_object");
        TS_ASSERT_EQUALS(b.super(), "_entity");

		std::string r_dotted = b.rank().dotted_str();
		// living_thing will be first child
		r_dotted.append(".1");

        tagd::tag c("living_thing", "physical_object");
        ts_rc = TS.put(c); // rank not updated
        TS_ASSERT_EQUALS(ts_rc, tagd::TAGD_OK);

        ts_rc = TS.get(c, c.id());  // get rank
        TS_ASSERT_EQUALS(ts_rc, tagd::TAGD_OK);
		
        TS_ASSERT_EQUALS(c.rank().dotted_str(), r_dotted);
    }

    void test_put_referent(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::referent a("thing", "physical_object");
        tagd_code ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_DUPLICATE");

		// same thing cannot refer to different tag in same context
        tagd::referent a1("thing", "_entity");
        TS.put(a1);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TS_DUPLICATE");

        tagd::referent b("doodoo", "caca");  // unknown refers_to
        ts_rc = TS.put(b);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_REFERS_TO_UNK");

        tagd::referent c("pictures", "movie", "oops");  // unknown context
        ts_rc = TS.put(c);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_CONTEXT_UNK");

		tagd::referent d("pictures", "movie", "event");
		ts_rc = TS.put(d);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

		tagd::tag photography("photography", "visual_art");
		TS.put(photography);

		// same thing cannot refer to different tag in same context
		tagd::referent d1("pictures", "photography", "event");
		ts_rc = TS.put(d1);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_DUPLICATE");

		//std::cout << "dump_terms: " << std::endl;
		//if (TS.dump_terms() != tagd::TAGD_OK)
		//	TS.print_errors();
    }

    void test_get_referent(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::referent thing("thing", "physical_object");
        TS.put(thing);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::tag t;
		TS.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id(), "physical_object" )
        TS_ASSERT( t.related(HARD_TAG_REFERENT, "thing") )
	}

    void test_ambiguous_referent(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::referent thing1("thing", "physical_object", "_entity");
        TS.put(thing1);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        tagd::referent thing2("thing", "animal", "living_thing");
        TS.put(thing2);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::tag t;
		TS.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TS_AMBIGUOUS")

		TS.push_context("living_thing");
		TS.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id(), "animal" )
        TS_ASSERT( t.related(HARD_TAG_REFERENT, "thing") )
	}

    void test_referent_override(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

		tagd::tag prg("cat_program", "program");
		TS.put(prg);

        tagd::referent cat("cat", "cat_program", "computer");
        TS.put(cat);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::tag t1;
		TS.get(t1, "cat");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t1.id(), "cat" )
        TS_ASSERT_EQUALS( t1.super(), "mammal" )

		TS.push_context("computer");
		tagd::tag t2;
		TS.get(t2, "cat");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t2.id(), "cat_program" )
        TS_ASSERT_EQUALS( t2.super(), "program" )
        TS_ASSERT( t2.related(HARD_TAG_REFERENT, "cat", "computer") )

		TS.push_context("animal");
		tagd::tag t3;
		TS.get(t3, "cat");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t3.id(), "cat" )
        TS_ASSERT_EQUALS( t3.super(), "mammal" )
	}

    void test_query_referents(void) {
        space_type TS;
        TS.init(db_fname);
        //TS.init("test.db");
        populate_tags(TS);
        tagd::referent thing_physical_object("thing", "physical_object");
        TS.put(thing_physical_object);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::abstract_tag t;
		TS.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id() , "physical_object" );
        TS_ASSERT( t.related(HARD_TAG_REFERENT, "thing") );

        tagd::referent thing_animal("thing", "animal", "living_thing");
        TS.put(thing_animal);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        tagd::referent creature("creature", "animal", "living_thing");
        TS.put(creature);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        tagd::tag_set S;
		// refers.empty() && refers_to.empty() && context.empty()
		// all referents
        tagd::interrogator q_referent("what", HARD_TAG_REFERENT);
        S.clear();
        TS.query(S, q_referent);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 3 );
        TS_ASSERT( tag_set_exists(S, thing_physical_object) );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
        TS_ASSERT( tag_set_exists(S, creature) );

		// refers.empty() && refers_to.empty() && !context.empty()
        tagd::interrogator q_context("what", HARD_TAG_REFERENT);
        q_context.relation(HARD_TAG_CONTEXT, "living_thing");
        S.clear();
        TS.query(S, q_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
        TS_ASSERT( tag_set_exists(S, creature) );

		// refers.empty() && !refers_to.empty() && context.empty()
        tagd::interrogator q_refers_to("what", HARD_TAG_REFERENT);
        q_refers_to.relation(HARD_TAG_REFERS_TO, "animal");
        S.clear();
        TS.query(S, q_refers_to);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
        TS_ASSERT( tag_set_exists(S, creature) );

		// refers.empty() && !refers_to.empty() && !context.empty()
        tagd::interrogator q_refers_to_context("what", HARD_TAG_REFERENT);
        q_refers_to_context.relation(HARD_TAG_REFERS_TO, "animal");
        q_refers_to_context.relation(HARD_TAG_CONTEXT, "physical_object");
		// living_thing _is_a physical_object
        S.clear();
        TS.query(S, q_refers_to_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
        TS_ASSERT( tag_set_exists(S, creature) );

		// !refers.empty() && refers_to.empty() && context.empty()
        tagd::interrogator q_refers("what", HARD_TAG_REFERENT);
        q_refers.relation(HARD_TAG_REFERS, "thing");
        S.clear();
        TS.query(S, q_refers);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, thing_physical_object) );
        TS_ASSERT( tag_set_exists(S, thing_animal) );

		// !refers.empty() && refers_to.empty() && !context.empty()
        tagd::interrogator q_refers_context("what", HARD_TAG_REFERENT);
        q_refers_context.relation(HARD_TAG_REFERS, "thing");
        q_refers_context.relation(HARD_TAG_CONTEXT, "physical_object");
        S.clear();
        TS.query(S, q_refers_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );

		// !refers.empty() && !refers_to.empty() && context.empty()
        tagd::interrogator q_refers_refers_to("what", HARD_TAG_REFERENT);
        q_refers_refers_to.relation(HARD_TAG_REFERS, "thing");
        q_refers_refers_to.relation(HARD_TAG_REFERS_TO, "animal");
        S.clear();
        TS.query(S, q_refers_refers_to);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );

		// !refers.empty() && !refers_to.empty() && !context.empty()
        tagd::interrogator q_refers_refers_to_context("what", HARD_TAG_REFERENT);
        q_refers_refers_to_context.relation(HARD_TAG_REFERS, "thing");
        q_refers_refers_to_context.relation(HARD_TAG_REFERS_TO, "animal");
        q_refers_refers_to_context.relation(HARD_TAG_CONTEXT, "physical_object");
        S.clear();
        TS.query(S, q_refers_refers_to_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
	}

	void test_context_stack(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::referent thing1("thing", "physical_object");
        TS.put(thing1);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        tagd::referent thing2("thing", "animal", "living_thing");
        TS.put(thing2);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        tagd::referent thing3("thing", "concept", "knowledge");
        TS.put(thing3);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::tag t1;
		TS.get(t1, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t1.id(), "physical_object" )
        TS_ASSERT( t1.related(HARD_TAG_REFERENT, "thing") )

		TS.push_context("living_thing");
		tagd::tag t2;
		TS.get(t2, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t2.id(), "animal" )
        TS_ASSERT( t2.related(HARD_TAG_REFERENT, "thing", "living_thing") )

		TS.push_context("mind");  // knowledge is_a mind
		tagd::tag t3;
		TS.get(t3, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t3.id(), "concept" )
        TS_ASSERT( t3.related(HARD_TAG_REFERENT, "thing", "mind") )

		TS.pop_context();
		tagd::tag t4;
		TS.get(t4, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t4.id(), "animal" )
        TS_ASSERT( t4.related(HARD_TAG_REFERENT, "thing", "living_thing") )

		TS.clear_context();
		tagd::tag t5;
		TS.get(t5, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t5.id(), "physical_object" )
        TS_ASSERT( t5.related(HARD_TAG_REFERENT, "thing") )
	}

    void test_utf8_japanese_referent(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

		tagd::tag japanese("japanese", "language");
		TS.put(japanese);

        tagd::referent jp_dog("イヌ", "dog", "japanese");
        TS.put(jp_dog);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::tag d;
		TS.get(d, "イヌ");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TS_AMBIGUOUS")

		tagd::tag t;
		TS.push_context("japanese");
		TS.get(t, "イヌ");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id(), "dog" )
        TS_ASSERT( t.related(HARD_TAG_REFERENT, "イヌ") )
	}

    void test_exists(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd_code ts_rc = TS.exists("dog");
        TS_ASSERT_EQUALS( ts_rc, tagd::TAGD_OK );

        ts_rc = TS.exists("unicorn");
        TS_ASSERT_EQUALS( ts_rc, tagd::TS_NOT_FOUND );
    }

    void test_pos(void) {
        space_type TS;
        TS.init(db_fname);
        //TS.init("test.db");
        populate_tags(TS);
		tagd::part_of_speech pos = TS.pos("dog");
		TS.print_errors();
        TS_ASSERT_EQUALS( pos_str(pos), "POS_TAG" )

		pos = TS.pos("_has");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_RELATOR" )

		pos = TS.pos("_is_a");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_SUPER" )

		pos = TS.pos("unicorn");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_UNKNOWN" )

    }

    void test_insert_relations(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags_minimal(TS);

        tagd::tag a("dog", "mammal");  // existing
        a.relation("has", "teeth");
        a.relation("has", "tail");
        a.relation("has", "legs", "4");
        tagd_code ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        tagd::tag b("robin", "bird");  // non-existing
        b.relation("has", "beak");
        b.relation("has", "wings");
        b.relation("has", "feathers");
        ts_rc = TS.put(b);
        TS_ASSERT_EQUALS(ts_rc, tagd::TAGD_OK);

        // already existing, only put relations
        tagd::tag c("dog");
        TS_ASSERT_EQUALS(c.super(), "");
        c.relation("can", "bark");
        ts_rc = TS.put(c);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
    }

    void test_duplicate(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags_minimal(TS);

        tagd::tag dog("dog", "mammal");
        tagd_code ts_rc = TS.put(dog); // duplicate tag, no relations
        TS_ASSERT_EQUALS( ts_rc, tagd::TS_DUPLICATE );

        dog.relation("has", "tail");
        ts_rc = TS.put(dog); // not duplicate, relation was inserted
        TS_ASSERT_EQUALS( ts_rc, tagd::TAGD_OK );

        ts_rc = TS.put(dog); // tag duplicate, relations duplicate
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TS_DUPLICATE" );

        dog.relation("can", "bark");
        ts_rc = TS.put(dog); // one duplicate (has tail), one insert (can bark)
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );

		TS.put(tagd::relator("wags", "move"));
		dog.relation("wags", "tail");
        ts_rc = TS.put(dog); // relator makes unique

        tagd::tag a("dog");
        a.relation("has", "tail");
        ts_rc = TS.put(a);  // existing tag, empty super, existing relation
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TS_DUPLICATE" );

        a.relation("has", "teeth");
        ts_rc = TS.put(a);  // existing tag, empty super, one new relation
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
    }

    void test_move(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag a("sea_creature", "living_thing");
        tagd_code ts_rc = TS.put(a);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );

        tagd::tag b("fish", "insect");
        ts_rc = TS.put(b);  // oops
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );

		b.super("sea_creature");
        ts_rc = TS.put(b);  // move
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
		size_t sz = a.rank().dotted_str().size();
		// a rank should prefix b rank
        TS_ASSERT_EQUALS( a.rank().dotted_str(), b.rank().dotted_str().substr(0, sz) )
    }

    void test_move_entity(void) {
        space_type TS;
        TS.init(db_fname);
        tagd::tag a("animal", "_entity");
        tagd_code ts_rc = TS.put(a);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );

        tagd::tag b("dog", "_entity");
        ts_rc = TS.put(b);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );

        tagd::tag c("dog", "animal");
        ts_rc = TS.put(c);  // move
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
		size_t sz = a.rank().dotted_str().size();
		// a rank should prefix c rank
        TS_ASSERT_EQUALS( a.rank().dotted_str(), c.rank().dotted_str().substr(0, sz) )
    }

    void test_undef_tag_refs(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags_minimal(TS);

        tagd::tag dog("dog", "nosuchthing");
        tagd_code ts_rc = TS.put(dog);
        TS_ASSERT_EQUALS( ts_rc, tagd::TS_SUPER_UNK );

        dog.super("mammal");
        dog.relation("has", "tailandwings");
        ts_rc = TS.put(dog);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TS_OBJECT_UNK" );

        dog.relations.clear();
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(dog.relation("flobdapperbates", "tail")), "TAGD_OK" );
        ts_rc = TS.put(dog);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TS_RELATOR_UNK" );

        tagd::tag a("dog");  // existing no super, no relations
        ts_rc = TS.put(a);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TS_DUPLICATE" );
    }

    void test_related(void) {
        space_type TS;
        TS.init(db_fname);
        //TS.init("tagspace.sqlite");
        populate_tags(TS);

		tagd_code ts_rc;
		tagd::tag t;

        tagd::tag_set S;
        ts_rc = TS.related(S, tagd::make_predicate("has", "legs")); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );

        S.empty();
        ts_rc = TS.related(S, tagd::make_predicate("_relator", "body_part")); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 8 );
        // for(tagd::tag_set::iterator it = S.begin(); it != S.end(); ++it) {
        //    std::cout << *it << std::endl;
        // }

        // TODO test related with existing and not existing supers

        ts_rc = TS.related(S, tagd::make_predicate("snarfs", "cockamamy")); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TS_NOT_FOUND" );
        TS_ASSERT_EQUALS( S.size(), 0 );
    }

    void test_query(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        // TODO "what" is not actually used in the query
        // this will change over time, as different types
        // of interrogators will denote different queries
        tagd::interrogator q("what", "mammal");
        q.relation("can", "swim");

        tagd::tag_set S;
        tagd_code ts_rc = TS.query(S, q);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, "whale") );

        S.clear();
        tagd::interrogator r("what");
        r.relation("has", "fangs");
        ts_rc = TS.query(S, r);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, "spider") );
        TS_ASSERT( tag_set_exists(S, "snake") );

        S.clear();
        tagd::interrogator s("what");
        s.relation("has", "teeth");
        ts_rc = TS.query(S, s);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 3 );
        TS_ASSERT( tag_set_exists(S, "mammal") );
        TS_ASSERT( tag_set_exists(S, "spider") );  // fangs are teeth
        TS_ASSERT( tag_set_exists(S, "snake") );

        // for(tagd::tag_set::iterator it = S.begin(); it != S.end(); ++it) {
        //    std::cout << *it << std::endl;
        // }
    }

    void test_query_super(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        // TODO "what" is not actually used in the query
        // this will change over time, as different types
        // of interrogators will denote different queries
        tagd::interrogator q("what", "mammal");

        tagd::tag_set S;
        tagd_code ts_rc = TS.query(S, q);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 4 );
        TS_ASSERT( tag_set_exists(S, "dog") );
        TS_ASSERT( tag_set_exists(S, "cat") );
        TS_ASSERT( tag_set_exists(S, "whale") );
        TS_ASSERT( tag_set_exists(S, "bat") );
    }

	void test_query_parent_relation(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::interrogator q("what");
        q.relation("has", "blood", "warm");
        q.relation("can", "swim");

        tagd::tag_set S;
        tagd_code ts_rc = TS.query(S, q);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, "whale") );
	}

    void test_get_hard_tag(void) {
		space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag t;
        tagd_code ts_rc = TS.get(t, "_url");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
        TS_ASSERT_EQUALS( t.id(), "_url" )
	}

    void test_put_hard_tag(void) {
		space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag t("_caca", "_entity");
        tagd_code ts_rc = TS.put(t);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_MISUSE");
	}

    void test_relations(void) {
		space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag dog;
        tagd_code ts_rc = TS.get(dog, "dog");

        TS_ASSERT_EQUALS( dog.relations.size(), 3 )
		TS_ASSERT( dog.related(tagd::make_predicate("has", "legs", "4"))  )
		TS_ASSERT( dog.related("has", "tail")  )

        tagd::id_type how;
		TS_ASSERT( dog.related("bark", &how) )
        TS_ASSERT_EQUALS( how, "can" )

		TS_ASSERT( !dog.related("has", "fins") )
	}

/// URI TESTS ///

    void test_put_url(void) {
        // std::cout << "\n#################### test_put_uri ####################\n";
        space_type TS;
        tagd_code ts_rc = TS.init(db_fname);
        //tagd_code ts_rc = TS.init("tagspace.db");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        populate_tags(TS);

        tagd::url a("http://www.hypermega.com/a/b/c?x=1&y=2#here");
        a.relation("about", "computer_security");
		TS_ASSERT_EQUALS(a.id(), "http://www.hypermega.com/a/b/c?x=1&y=2#here"); 
        ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
		TS_ASSERT_EQUALS(a.id(), "http://www.hypermega.com/a/b/c?x=1&y=2#here"); 

        tagd::url b;
        ts_rc = TS.get(b, a.id()); 
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
		TS_ASSERT_EQUALS(b.id(), "http://www.hypermega.com/a/b/c?x=1&y=2#here"); 
		TS_ASSERT_EQUALS(b.hduri(), "com:hypermega:www:/a/b/c:?x=1&y=2:here:http");
        TS_ASSERT( b.relations.size() > 1 )
        TS_ASSERT( b.related("about", "computer_security") )
        TS_ASSERT( b.related("_has", HARD_TAG_SCHEME, "http") )
        TS_ASSERT( b.related("_has", HARD_TAG_HOST, "hypermega.com") )
        TS_ASSERT( b.related("_has", HARD_TAG_PRIV_LABEL, "hypermega") )
        TS_ASSERT( b.related("_has", HARD_TAG_PUB, "com") )
        TS_ASSERT( b.related("_has", HARD_TAG_SUB, "www") )
        TS_ASSERT( b.related("_has", HARD_TAG_PATH, "/a/b/c") )
        TS_ASSERT( b.related("_has", HARD_TAG_QUERY, "?x=1&y=2") )
        TS_ASSERT( b.related("_has", HARD_TAG_FRAGMENT, "here") )
    }

    void test_get_hduri(void) {
        space_type TS;
        tagd_code ts_rc = TS.init(db_fname);
        //tagd_code ts_rc = TS.init("tagspace.db");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        populate_tags(TS);

        tagd::url a("http://www.hypermega.com/a/b/c?x=1&y=2#here");
        a.relation("about", "computer_security");
        ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        tagd::abstract_tag b;
        ts_rc = TS.get(b, a.hduri()); 
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
		TS_ASSERT_EQUALS(b.id(), "com:hypermega:www:/a/b/c:?x=1&y=2:here:http");
        TS_ASSERT_EQUALS( b.super() , HARD_TAG_URL )
        TS_ASSERT( b.related("about", "computer_security") )
        TS_ASSERT( b.related("_has", HARD_TAG_SCHEME, "http") )
        TS_ASSERT( b.related("_has", HARD_TAG_HOST, "hypermega.com") )
        TS_ASSERT( b.related("_has", HARD_TAG_PRIV_LABEL, "hypermega") )
        TS_ASSERT( b.related("_has", HARD_TAG_PUB, "com") )
        TS_ASSERT( b.related("_has", HARD_TAG_SUB, "www") )
        TS_ASSERT( b.related("_has", HARD_TAG_PATH, "/a/b/c") )
        TS_ASSERT( b.related("_has", HARD_TAG_QUERY, "?x=1&y=2") )
        TS_ASSERT( b.related("_has", HARD_TAG_FRAGMENT, "here") )
    }

    void test_query_url(void) {
        space_type TS;
		tagd_code ts_rc;
        TS.init(db_fname);
        // TS.init("tagspace.sqlite");
        populate_tags(TS);

        tagd::url a("http://en.wikipedia.org/wiki/Dog");
        a.relation("about", "dog");
        ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

		tagd::tag starwars("starwars", "movie");
		TS.put(starwars);
        tagd::url b("http://starwars.wikia.com/wiki/Dog");
        b.relation("about", "starwars");
        ts_rc = TS.put(b);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        tagd::url c("http://animal.discovery.com/tv-shows/dogs-101");
        c.relation("about", "dog");
        ts_rc = TS.put(c);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        // TODO "what" is not actually used in the query
        tagd::interrogator q("what", "_url");
        q.relation("about", "dog");

        tagd::tag_set S;
        ts_rc = TS.query(S, q);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, "http://en.wikipedia.org/wiki/Dog") );
        TS_ASSERT( tag_set_exists(S, "http://animal.discovery.com/tv-shows/dogs-101") );

        S.clear();
        tagd::interrogator r("what", "_url");
        r.relation("_has", "_path", "/wiki/Dog");
        ts_rc = TS.query(S, r);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, "http://en.wikipedia.org/wiki/Dog") );
        TS_ASSERT( tag_set_exists(S, "http://starwars.wikia.com/wiki/Dog") );
    }

    void test_util(void) {
		std::string db_file = tagspace::util::user_db();
		TS_ASSERT( !db_file.empty() )
	}

//    void test_dump(void) {
//        space_type TS;
//        TS.init(db_fname);
//		std::cout << std::endl;
//        populate_tags(TS);
//		TS.dump();
//	}

//	void test_dump_terms(void) {
//        space_type TS;
//        TS.init(db_fname);
//		std::cout << std::endl;
//        populate_tags(TS);
//		TS.dump_terms();
//	}

};
