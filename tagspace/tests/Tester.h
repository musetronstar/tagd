// Test suites

#include <cxxtest/TestSuite.h>

#include "tagd.h"
#include "tagspace/sqlite.h"

//const std::string db_fname = "tagspace.sqlite";
const std::string db_fname = ":memory:";

// TODO we may wish to define this in a config.h
// generated by the Makefile, so that these tests
// can be used by other tagspace implementation
typedef tagspace::sqlite space_type;

// populate tags
// return the number of referents inserted
size_t populate_tags(space_type& TS) {
	size_t num_referents = 0;

    TS.put( tagd::tag("substance", HARD_TAG_ENTITY) );
    TS.put( tagd::tag("physical_object", HARD_TAG_ENTITY) );
    TS.put( tagd::tag("living_thing", "physical_object") );
    // TODO change plural referents when referents in place
    TS.put( tagd::tag("body_part","physical_object") );
    TS.put( tagd::tag("teeth","body_part") );  // plural referent => tooth, for now, what the hell
    TS.put( tagd::tag("fangs","teeth") );
    TS.put( tagd::tag("fur","body_part") );
    TS.put( tagd::tag("tail","body_part") );
    TS.put( tagd::tag("legs","body_part") );  // plural referent
    TS.put( tagd::tag("beak","body_part") );
    TS.put( tagd::tag("wings","body_part") );  // plural referent
    TS.put( tagd::tag("feathers","body_part") );  // plural referent
    TS.put( tagd::tag("fins","body_part") );  // plural referent

	TS.put( tagd::tag("machine", "physical_object") );
	TS.put( tagd::tag("computer", "machine") );

    TS.put( tagd::tag("mind", HARD_TAG_ENTITY) );

    TS.put( tagd::tag("communication", HARD_TAG_ENTITY) );
    TS.put( tagd::tag("language", "communication") );
	TS.put( tagd::tag("instruction", "language") );
	TS.put( tagd::tag("program", "instruction") );

    TS.put( tagd::tag("knowledge", "mind") );
    TS.put( tagd::tag("concept", "knowledge") );
    TS.put( tagd::tag("science", "knowledge") );
	TS.put( tagd::tag("computer_security", "science") );

	TS.put( tagd::tag("creativity", "mind") );
	TS.put( tagd::tag("art", "creativity") );
	TS.put( tagd::tag("visual_art", "art") );
	TS.put( tagd::tag("movie", "visual_art") );
	TS.put( tagd::tag("tv_show", "visual_art") );

    TS.put( tagd::tag("event",HARD_TAG_ENTITY) );
    TS.put( tagd::tag("sound","event") );
    TS.put( tagd::tag("action","event") );
    TS.put( tagd::tag("utterance","sound") );
    TS.put( tagd::tag("bark","utterance") );
    TS.put( tagd::tag("meow","utterance") );
    // TODO these are verbs, how do we deal with them?
    TS.put( tagd::tag("move","action") );  // to_move
    TS.put( tagd::tag("fly","move") );    // to_fly
    TS.put( tagd::tag("swim","move") );    // to_swim

    TS.put( tagd::relator("verb","_relator") );
    TS.put( tagd::relator("can","verb") );  // no hard_tagd == _can, so no referent
    TS.put( tagd::relator("preposition","_relator") );
    TS.put( tagd::relator("about","preposition") );

    TS.put( tagd::referent("is_a","_is_a") );
	num_referents++;
    TS.put( tagd::referent("has","_has") );
	num_referents++;

    TS.put( tagd::tag("body_fluid", "substance") );
    TS.put( tagd::tag("blood", "body_fluid") );
    TS.put( tagd::tag("animal", "living_thing") );
    TS.put( tagd::tag("vertibrate", "animal") );

    tagd::tag mammal("mammal","vertibrate");
    mammal.relation("has", "blood", "warm");
    mammal.relation("has", "teeth");
    TS.put(mammal);

    TS.put( tagd::tag("reptile","vertibrate") );
    TS.put( tagd::tag("invertebrate","animal") );
    TS.put( tagd::tag("arthropod","invertebrate") );
    TS.put( tagd::tag("insect","arthropod") );

    tagd::tag dog("dog", "mammal");
    dog.relation("has", "legs", "4");
    dog.relation("has", "tail");
    dog.relation("can", "bark");
    TS.put(dog);

    tagd::tag cat("cat", "mammal");
    cat.relation("has", "legs", "4");
    cat.relation("has", "tail");
    cat.relation("can", "meow");
    TS.put(cat);

    tagd::tag whale("whale", "mammal");
    whale.relation("has", "fins");
    whale.relation("can", "swim");
    TS.put(whale);

    tagd::tag bat("bat", "mammal");
    bat.relation("has", "wings");
    bat.relation("can", "fly");
    TS.put(bat);

    tagd::tag bird("bird", "vertibrate");
    bird.relation("has", "wings");
    bird.relation("has", "feathers");
    bird.relation("can", "fly");
    TS.put(bird);

    TS.put( tagd::tag("canary","bird") );

    tagd::tag spider("spider", "insect");
    spider.relation("has", "fangs");
    TS.put(spider);

    tagd::tag snake("snake", "reptile");
    snake.relation("has", "fangs");
    TS.put(snake);

	return num_referents;
}

bool tag_set_exists(const tagd::tag_set& S, const tagd::id_type& id) {
    for(tagd::tag_set::iterator it = S.begin(); it != S.end(); ++it)
        if (it->id() == id) return true;

    return false;
}

bool tag_set_exists(const tagd::tag_set& S, const tagd::abstract_tag& t) {
    for(tagd::tag_set::iterator it = S.begin(); it != S.end(); ++it)
        if (*it == t) return true;

    return false;
}

#define TAGD_CODE_STRING(c)	std::string(tagd_code_str(c))

class Tester : public CxxTest::TestSuite {
    public:

    void test_init(void) {
        space_type TS;
        tagd_code ts_rc = TS.init(db_fname);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        tagd::tag t;
        ts_rc = TS.get(t, HARD_TAG_ENTITY);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
        TS_ASSERT_EQUALS(t.id(), HARD_TAG_ENTITY);
        TS_ASSERT_EQUALS(t.super_object(), HARD_TAG_ENTITY);
    }

    void test_put_get_rank(void) {
        space_type TS;
        TS.init(db_fname);

        tagd::tag a("physical_object", HARD_TAG_ENTITY);
        tagd_code ts_rc = TS.put(a);

        tagd::tag b;
        ts_rc = TS.get(b, "physical_object");
        TS_ASSERT_EQUALS(ts_rc, tagd::TAGD_OK);
        TS_ASSERT_EQUALS(b.id(), "physical_object");
        TS_ASSERT_EQUALS(b.super_object(), HARD_TAG_ENTITY);

		std::string r_dotted = b.rank().dotted_str();
		// living_thing will be first child
		r_dotted.append(".1");

        tagd::tag c("living_thing", "physical_object");
        ts_rc = TS.put(c); // rank not updated
        TS_ASSERT_EQUALS(ts_rc, tagd::TAGD_OK);

        ts_rc = TS.get(c, c.id());  // get rank
        TS_ASSERT_EQUALS(ts_rc, tagd::TAGD_OK);
		
        TS_ASSERT_EQUALS(c.rank().dotted_str(), r_dotted);
    }

	void test_put_id_equals_super_object(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag a("dog", "dog");
        TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TS_MISUSE");
    }

    void test_put_referent(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::referent a("thing", "physical_object");
        tagd_code ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_DUPLICATE");

		// same thing cannot refer to different tag in same context
        tagd::referent a1("thing", "animal");
        TS.put(a1);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TS_DUPLICATE");

        tagd::referent b("doodoo", "caca");  // unknown refers_to
        ts_rc = TS.put(b);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_REFERS_TO_UNK");

        tagd::referent c("pictures", "movie", "oops");  // unknown context
        ts_rc = TS.put(c);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_CONTEXT_UNK");

		tagd::referent d("pictures", "movie", "event");
		ts_rc = TS.put(d);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

		tagd::tag photography("photography", "visual_art");
		TS.put(photography);

		// same thing cannot refer to different tag in same context
		tagd::referent d1("pictures", "photography", "event");
		ts_rc = TS.put(d1);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_DUPLICATE");
    }

	void test_put_refers_to_self(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::referent a("thing", "thing");
        TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TS_MISUSE");

        tagd::referent b("dog", "dog");
        TS.put(b);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TS_MISUSE");
    }

	void test_delete_tag(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag a;
        tagd_code ts_rc = TS.get(a, "dog");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        tagd::tag b("dog");
        ts_rc = TS.del(b);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        tagd::tag c;
        ts_rc = TS.get(c, "dog");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_NOT_FOUND");
		TS.clear_errors();

		// delete tag that is a super_object and relations.object
		ts_rc = TS.del(tagd::tag("teeth"));
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_FOREIGN_KEY");
		TS_ASSERT_EQUALS( TS.errors().size() , 2 );
		if (TS.errors().size() == 2) {
			auto it = TS.errors().begin();
			TS_ASSERT( it->related(HARD_TAG_CAUSED_BY, "super_object", "teeth") );
			it++;
			TS_ASSERT( it->related(HARD_TAG_CAUSED_BY, "object", "teeth") );
		}
		TS.clear_errors();

		// delete failed, so tag still exists
		tagd::tag d;
		ts_rc = TS.get(d, "teeth");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
		TS.clear_errors();

		// delete tag that is a super_object and has relations
		ts_rc = TS.del(tagd::tag("mammal"));
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_FOREIGN_KEY");

		// delete failed, so tag and relations still exists
		tagd::tag e;
		ts_rc = TS.get(e, "mammal");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
		TS_ASSERT_EQUALS( e.super_object() , "vertibrate" );
		TS_ASSERT( e.related("has", "blood", "warm") );
		TS_ASSERT( e.related("has", "teeth") );
    }

	void test_delete_relations(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag a;
        tagd_code ts_rc = TS.get(a, "dog");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        tagd::tag b("dog");
		b.relation("has", "tail");
		b.relation("can", "bark");
        ts_rc = TS.del(b);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
		TS.clear_errors();

        tagd::tag c;
        ts_rc = TS.get(c, "dog");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
		TS_ASSERT( c.related("has", "legs", "4") )
		TS_ASSERT( !c.related("has", "tail")  )
		TS_ASSERT( !c.related("can", "bark")  )

		// delete relation it doesn't have
		tagd::tag d("dog");
		d.relation("can", "meow");
        ts_rc = TS.del(d);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_NOT_FOUND");
		TS_ASSERT_EQUALS( std::string("cannot delete non-existent relation: dog can meow"), TS.last_error().message() )
		TS.clear_errors();

		// delete unknown tag
		tagd::tag e("snarf");
        ts_rc = TS.del(e);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_NOT_FOUND");
    }

	void test_get_referent(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::referent thing("thing", "physical_object");
        TS.put(thing);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::tag t;
		TS.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id(), "thing" )
        TS_ASSERT( t.related(HARD_TAG_REFERS_TO, "physical_object") )
	}

    void test_refers_to(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::referent thing("thing", "physical_object");
        TS.put(thing);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::tag t;
		TS.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id(), "thing" )
        TS_ASSERT( t.related(HARD_TAG_REFERS_TO, "physical_object") )

        tagd::referent thing2("thing", "animal", "living_thing");
        TS.put(thing2);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::id_type refers_to;
		TS.refers_to(refers_to, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( refers_to , "physical_object" )

		refers_to.clear();
		TS.refers_to(refers_to, "physical_object"); // not a referent
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TS_NOT_FOUND")

		TS.push_context("living_thing");
		refers_to.clear();
		TS.refers_to(refers_to, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( refers_to , "animal" )

		tagd::part_of_speech p1 = TS.pos("animal");
		tagd::part_of_speech p2 = TS.pos("thing");
		TS_ASSERT_EQUALS ( pos_str(p1) , "POS_TAG" )
		TS_ASSERT_EQUALS ( p1 , p2 )
	}

    void test_ambiguous_referent(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::referent thing1("thing", "physical_object", HARD_TAG_ENTITY);
        TS.put(thing1);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        tagd::referent thing2("thing", "animal", "living_thing");
        TS.put(thing2);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::tag t;
		TS.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TS_AMBIGUOUS")

		TS.push_context("living_thing");
		TS.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id(), "thing" )
        TS_ASSERT( t.related(HARD_TAG_REFERS_TO, "animal") )
	}

    void test_referent_override(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

		tagd::tag prg("cat_program", "program");
		TS.put(prg);

        tagd::referent cat("cat", "cat_program", "computer");
        TS.put(cat);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::tag t1;
		TS.get(t1, "cat");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t1.id(), "cat" )
        TS_ASSERT_EQUALS( t1.super_object(), "mammal" )

		TS.push_context("computer");
		tagd::tag t2;
		TS.get(t2, "cat");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t2.id(), "cat" )
        TS_ASSERT_EQUALS( t2.super_object(), "program" )
        TS_ASSERT( t2.related(HARD_TAG_REFERS_TO, "cat_program") )

		TS.push_context("animal");
		tagd::tag t3;
		TS.get(t3, "cat");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t3.id(), "cat" )
        TS_ASSERT_EQUALS( t3.super_object(), "mammal" )
	}

    void test_query_referents(void) {
        space_type TS;
        TS.init(db_fname);
        //TS.init("test.db");
        size_t num_referents = populate_tags(TS);
        tagd::referent thing_physical_object("thing", "physical_object");
        TS.put(thing_physical_object);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::abstract_tag t;
		TS.get(t, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id() , "thing" );
        TS_ASSERT( t.related(HARD_TAG_REFERS_TO, "physical_object") );

        tagd::referent thing_animal("thing", "animal", "living_thing");
        TS.put(thing_animal);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        tagd::referent creature("creature", "animal", "living_thing");
        TS.put(creature);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        tagd::tag_set S;
		// refers.empty() && refers_to.empty() && context.empty()
		// all referents
        tagd::interrogator q_referent("what", HARD_TAG_REFERENT);
        S.clear();
        TS.query(S, q_referent);
		//tagd::print_tags(S);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), (3+num_referents) );
        TS_ASSERT( tag_set_exists(S, thing_physical_object) );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
        TS_ASSERT( tag_set_exists(S, creature) );

		// refers.empty() && refers_to.empty() && !context.empty()
        tagd::interrogator q_context("what", HARD_TAG_REFERENT);
        q_context.relation(HARD_TAG_CONTEXT, "living_thing");
        S.clear();
        TS.query(S, q_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
        TS_ASSERT( tag_set_exists(S, creature) );

		// refers.empty() && !refers_to.empty() && context.empty()
        tagd::interrogator q_refers_to("what", HARD_TAG_REFERENT);
        q_refers_to.relation(HARD_TAG_REFERS_TO, "animal");
        S.clear();
        TS.query(S, q_refers_to);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
        TS_ASSERT( tag_set_exists(S, creature) );

		// refers.empty() && !refers_to.empty() && !context.empty()
        tagd::interrogator q_refers_to_context("what", HARD_TAG_REFERENT);
        q_refers_to_context.relation(HARD_TAG_REFERS_TO, "animal");
        q_refers_to_context.relation(HARD_TAG_CONTEXT, "physical_object");
		// living_thing _is_a physical_object
        S.clear();
        TS.query(S, q_refers_to_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
        TS_ASSERT( tag_set_exists(S, creature) );

		// !refers.empty() && refers_to.empty() && context.empty()
        tagd::interrogator q_refers("what", HARD_TAG_REFERENT);
        q_refers.relation(HARD_TAG_REFERS, "thing");
        S.clear();
        TS.query(S, q_refers);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, thing_physical_object) );
        TS_ASSERT( tag_set_exists(S, thing_animal) );

		// !refers.empty() && refers_to.empty() && !context.empty()
        tagd::interrogator q_refers_context("what", HARD_TAG_REFERENT);
        q_refers_context.relation(HARD_TAG_REFERS, "thing");
        q_refers_context.relation(HARD_TAG_CONTEXT, "physical_object");
        S.clear();
        TS.query(S, q_refers_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );

		// !refers.empty() && !refers_to.empty() && context.empty()
        tagd::interrogator q_refers_refers_to("what", HARD_TAG_REFERENT);
        q_refers_refers_to.relation(HARD_TAG_REFERS, "thing");
        q_refers_refers_to.relation(HARD_TAG_REFERS_TO, "animal");
        S.clear();
        TS.query(S, q_refers_refers_to);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );

		// !refers.empty() && !refers_to.empty() && !context.empty()
        tagd::interrogator q_refers_refers_to_context("what", HARD_TAG_REFERENT);
        q_refers_refers_to_context.relation(HARD_TAG_REFERS, "thing");
        q_refers_refers_to_context.relation(HARD_TAG_REFERS_TO, "animal");
        q_refers_refers_to_context.relation(HARD_TAG_CONTEXT, "physical_object");
        S.clear();
        TS.query(S, q_refers_refers_to_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, thing_animal) );
	}

	void test_context_stack(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::referent thing1("thing", "physical_object");
        TS.put(thing1);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        tagd::referent thing2("thing", "animal", "living_thing");
        TS.put(thing2);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        tagd::referent thing3("thing", "concept", "knowledge");
        TS.put(thing3);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::tag t1;
		TS.get(t1, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t1.id(), "thing" )
        TS_ASSERT( t1.related(HARD_TAG_REFERS_TO, "physical_object") )

		TS.push_context("living_thing");
		tagd::tag t2;
		TS.get(t2, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t2.id(), "thing" )
        TS_ASSERT( t2.related(HARD_TAG_REFERS_TO, "animal") )

		TS.push_context("mind");  // knowledge is_a mind
		tagd::tag t3;
		TS.get(t3, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t3.id(), "thing" )
        TS_ASSERT( t3.related(HARD_TAG_REFERS_TO, "concept" ) )

		TS.pop_context();
		tagd::tag t4;
		TS.get(t4, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t4.id(), "thing" )
        TS_ASSERT( t4.related(HARD_TAG_REFERS_TO, "animal") )

		TS.clear_context();
		tagd::tag t5;
		TS.get(t5, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t5.id(), "thing" )
        TS_ASSERT( t5.related(HARD_TAG_REFERS_TO, "physical_object") )
	}

    void test_utf8_japanese_referent(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

		tagd::tag japanese("japanese", "language");
		TS.put(japanese);

        tagd::referent jp_dog("イヌ", "dog", "japanese");
        TS.put(jp_dog);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::tag d;
		TS.get(d, "イヌ");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TS_AMBIGUOUS")

		tagd::tag t;
		TS.push_context("japanese");
		TS.get(t, "イヌ");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( t.id(), "イヌ" )
        TS_ASSERT( t.related(HARD_TAG_REFERS_TO, "dog") )
	}

	void test_delete_referents(void) {
        space_type TS;
        TS.init(db_fname);
        //TS.init("test.db");
        populate_tags(TS);

        TS.put( tagd::referent("thing", "physical_object") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        TS.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        TS.put( tagd::referent("creature", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		// non existant referent
        TS.del( tagd::referent("snarf", "living_thing") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TS_NOT_FOUND" );

		// refers.empty() && refers_to.empty() && context.empty()
        TS.del( tagd::referent() );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TS_MISUSE" );

		// refers.empty() && refers_to.empty() && !context.empty()
        TS.del( tagd::referent("", "", "living_thing") );
        tagd::interrogator q_context("what", HARD_TAG_REFERENT);
        q_context.relation(HARD_TAG_CONTEXT, "living_thing");
		tagd::tag_set S;
        TS.query(S, q_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TS_NOT_FOUND" );

		// check that thing physical_object still exists
		tagd::id_type what;
        TS.refers_to(what, "thing");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
        TS_ASSERT_EQUALS( what , "physical_object" );

        TS.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        TS.put( tagd::referent("creature", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		// refers.empty() && !refers_to.empty() && context.empty()
		TS.del( tagd::referent("", "animal", "") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );

		// already deleted - does not exist
		TS.del( tagd::referent("", "animal", "") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TS_NOT_FOUND" );
		
		TS.push_context("living_thing");
		what.clear();
		TS.refers(what, "thing");
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TS_NOT_FOUND" );
		TS.clear_context();

        TS.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        TS.put( tagd::referent("creature", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		// refers.empty() && !refers_to.empty() && !context.empty()
		TS.del( tagd::referent("", "animal", "living_thing") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );

        tagd::interrogator q_refers_to_context("what", HARD_TAG_REFERENT);
        q_refers_to_context.relation(HARD_TAG_REFERS_TO, "animal");
        q_refers_to_context.relation(HARD_TAG_CONTEXT, "living_thing");
        S.clear();
        TS.query(S, q_refers_to_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TS_NOT_FOUND" );

        TS.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        TS.put( tagd::referent("creature", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		// !refers.empty() && refers_to.empty() && context.empty()
		TS.del( tagd::referent("thing", "", "") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );

        tagd::interrogator q_refers("what", HARD_TAG_REFERENT);
        q_refers.relation(HARD_TAG_REFERS, "thing");
        S.clear();
        TS.query(S, q_refers);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TS_NOT_FOUND" );

		// make sure the other referent to animal still exists
		TS.push_context("living_thing");
		what.clear();
		TS.refers(what, "animal");
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( what, "creature" );
		TS.clear_context();

        TS.put( tagd::referent("thing", "physical_object") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

        TS.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		// !refers.empty() && refers_to.empty() && !context.empty()
		TS.del( tagd::referent("thing", "", "living_thing") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );

        tagd::interrogator q_refers_context("what", HARD_TAG_REFERENT);
        q_refers_context.relation(HARD_TAG_REFERS, "thing");
        q_refers_context.relation(HARD_TAG_CONTEXT, "living_thing");
        S.clear();
        TS.query(S, q_refers_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TS_NOT_FOUND" );

		// make sure the other referent to animal still exists
		TS.push_context("living_thing");
		what.clear();
		TS.refers(what, "animal");
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( what, "creature" );
		TS.clear_context();

        TS.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		// !refers.empty() && !refers_to.empty() && context.empty()
		TS.del( tagd::referent("thing", "animal") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );

        tagd::interrogator q_refers_refers_to("what", HARD_TAG_REFERENT);
        q_refers_refers_to.relation(HARD_TAG_REFERS, "thing");
        q_refers_refers_to.relation(HARD_TAG_REFERS_TO, "animal");
        S.clear();
        TS.query(S, q_refers_refers_to);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TS_NOT_FOUND" );

        TS.put( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		// !refers.empty() && !refers_to.empty() && !context.empty()
		TS.del( tagd::referent("thing", "animal", "living_thing") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );

		tagd::interrogator q_refers_refers_to_context("what", HARD_TAG_REFERENT);
        q_refers_refers_to_context.relation(HARD_TAG_REFERS, "thing");
        q_refers_refers_to_context.relation(HARD_TAG_REFERS_TO, "animal");
        q_refers_refers_to_context.relation(HARD_TAG_CONTEXT, "living_thing");
        S.clear();
        TS.query(S, q_refers_refers_to_context);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TS_NOT_FOUND" );

		// make sure other thing exists
		what.clear();
		TS.refers_to(what, "thing");
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );
        TS_ASSERT_EQUALS( what, "physical_object" );

		// delete using refers that would delete refers_to
		TS.del( tagd::tag("thing") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TS_MISUSE" );

		// test referent gets wiped out
		TS.put( tagd::referent("thingy", "physical_object") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );

		TS.del( tagd::referent("thingy", "physical_object") );
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TAGD_OK" );

		tagd::abstract_tag t;
		TS.get(t, "thingy");
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(TS.code()), "TS_NOT_FOUND" );
	}

    void test_exists(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd_code ts_rc = TS.exists("dog");
        TS_ASSERT_EQUALS( ts_rc, tagd::TAGD_OK );

        ts_rc = TS.exists("unicorn");
        TS_ASSERT_EQUALS( ts_rc, tagd::TS_NOT_FOUND );
    }

    void test_pos(void) {
        space_type TS;
        TS.init(db_fname);
        //TS.init("test.db");
        populate_tags(TS);
		tagd::part_of_speech pos = TS.pos("dog");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_TAG" )

		pos = TS.pos("_has");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_RELATOR" )

		pos = TS.pos("has");  // referent relator
        TS_ASSERT_EQUALS( pos_str(pos), "POS_RELATOR" )

		pos = TS.pos("_is_a");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_SUPER_RELATOR" )

		pos = TS.pos("is_a");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_SUPER_RELATOR" )

		pos = TS.pos("unicorn");
        TS_ASSERT_EQUALS( pos_str(pos), "POS_UNKNOWN" )

    }

    void test_insert_relations(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag a("dog", "mammal");  // existing
        a.relation("has", "teeth");
        a.relation("has", "tail");
        a.relation("has", "legs", "4");
        tagd_code ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        tagd::tag b("robin", "bird");  // non-existing
        b.relation("has", "beak");
        b.relation("has", "wings");
        b.relation("has", "feathers");
        ts_rc = TS.put(b);
        TS_ASSERT_EQUALS(ts_rc, tagd::TAGD_OK);

		TS.put( tagd::tag("bite", "action") );
        // already existing, only put relations
        tagd::tag c("dog");
        c.relation("can", "bite");
        ts_rc = TS.put(c);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

		tagd::tag d;
		ts_rc = TS.get(d, "dog");
		TS_ASSERT( d.related("has", "legs", "4") )
		TS_ASSERT( d.related("has", "tail")  )
		TS_ASSERT( d.related("can", "bite")  )
    }

    void test_duplicate(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag dog("dog", "mammal");
        tagd_code ts_rc = TS.put(dog); // duplicate tag, no relations
        TS_ASSERT_EQUALS( ts_rc, tagd::TS_DUPLICATE );

        dog.relation("has", "fur");
        ts_rc = TS.put(dog); // not duplicate, relation was inserted
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        ts_rc = TS.put(dog); // tag duplicate, relations duplicate
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TS_DUPLICATE" );

		TS.put( tagd::tag("bite", "action") );
        dog.relation("can", "bite");
        ts_rc = TS.put(dog); // one duplicate (has tail), one insert (can bite)
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );

		TS.put(tagd::relator("wags", "move"));
		dog.relation("wags", "tail");
        ts_rc = TS.put(dog); // relator makes unique

        tagd::tag a("dog");
        a.relation("has", "tail");
        ts_rc = TS.put(a);  // existing tag, empty super, existing relation
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TS_DUPLICATE" );

        a.relation("has", "teeth");
        ts_rc = TS.put(a);  // existing tag, empty super, one new relation
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
    }

    void test_ignore_duplicate(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag dog("dog", "mammal");
        tagd_code ts_rc = TS.put(dog, tagspace::F_IGNORE_DUPLICATES); // duplicate tag, no relations
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        dog.relation("has", "fur");
        ts_rc = TS.put(dog, tagspace::F_IGNORE_DUPLICATES); // not duplicate, relation was inserted
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        ts_rc = TS.put(dog, tagspace::F_IGNORE_DUPLICATES); // tag duplicate, relations duplicate
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

		TS.put( tagd::tag("bite", "action") );
        dog.relation("can", "bite");
        ts_rc = TS.put(dog, tagspace::F_IGNORE_DUPLICATES); // one duplicate (has tail), one insert (can bite)
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );

		TS.put(tagd::relator("wags", "move"));
		dog.relation("wags", "tail");
        ts_rc = TS.put(dog, tagspace::F_IGNORE_DUPLICATES); // relator makes unique

        tagd::tag a("dog");
        a.relation("has", "tail");
        ts_rc = TS.put(a, tagspace::F_IGNORE_DUPLICATES);  // existing tag, empty super, existing relation
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );

        a.relation("has", "teeth");
        ts_rc = TS.put(a, tagspace::F_IGNORE_DUPLICATES);  // existing tag, empty super, one new relation
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
    }

    void test_move(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag a("sea_creature", "living_thing");
        tagd_code ts_rc = TS.put(a);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );

        tagd::tag b("fish", "insect");
        ts_rc = TS.put(b);  // oops
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );

		b.super_object("sea_creature");
        ts_rc = TS.put(b);  // move
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
		size_t sz = a.rank().dotted_str().size();
		// a rank should prefix b rank
        TS_ASSERT_EQUALS( a.rank().dotted_str(), b.rank().dotted_str().substr(0, sz) )
    }

    void test_move_entity(void) {
        space_type TS;
        TS.init(db_fname);
        tagd::tag a("animal", HARD_TAG_ENTITY);
        tagd_code ts_rc = TS.put(a);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );

        tagd::tag b("dog", HARD_TAG_ENTITY);
        ts_rc = TS.put(b);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );

        tagd::tag c("dog", "animal");
        ts_rc = TS.put(c);  // move
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
		size_t sz = a.rank().dotted_str().size();
		// a rank should prefix c rank
        TS_ASSERT_EQUALS( a.rank().dotted_str(), c.rank().dotted_str().substr(0, sz) )
    }

    void test_undef_tag_refs(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag dog("dog", "nosuchthing");
        tagd_code ts_rc = TS.put(dog);
        TS_ASSERT_EQUALS( ts_rc, tagd::TS_SUPER_UNK );

        dog.super_object("mammal");
        dog.relation("has", "tailandwings");
        ts_rc = TS.put(dog);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TS_OBJECT_UNK" );

        dog.relations.clear();
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(dog.relation("flobdapperbates", "tail")), "TAGD_OK" );
        ts_rc = TS.put(dog);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TS_RELATOR_UNK" );

        tagd::tag a("dog");  // existing no super, no relations
        ts_rc = TS.put(a);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TS_MISUSE" );
    }

    void test_related(void) {
        space_type TS;
        TS.init(db_fname);
        //TS.init("tagspace.sqlite");
        populate_tags(TS);

		tagd_code ts_rc;
		tagd::tag t;

        tagd::tag_set S;
        ts_rc = TS.related(S, tagd::make_predicate("has", "legs")); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );

        S.empty();
        ts_rc = TS.related(S, tagd::make_predicate("_relator", "body_part")); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 8 );
        // for(tagd::tag_set::iterator it = S.begin(); it != S.end(); ++it) {
        //    std::cout << *it << std::endl;
        // }

        // TODO test related with existing and not existing supers

        ts_rc = TS.related(S, tagd::make_predicate("snarfs", "cockamamy")); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TS_NOT_FOUND" );
        TS_ASSERT_EQUALS( S.size(), 0 );

        S.clear();
        ts_rc = TS.related(S, tagd::make_predicate("can", "")); 
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 5 )
    }

    void test_query(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        // TODO "what" is not actually used in the query
        // this will change over time, as different types
        // of interrogators will denote different queries
        tagd::interrogator q("what", "mammal");
        q.relation("can", "swim");

        tagd::tag_set S;
        tagd_code ts_rc = TS.query(S, q);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, "whale") );

        S.clear();
        tagd::interrogator r("what");
        r.relation("has", "fangs");
        ts_rc = TS.query(S, r);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, "spider") );
        TS_ASSERT( tag_set_exists(S, "snake") );

        S.clear();
        tagd::interrogator s("what");
        s.relation("has", "teeth");
        ts_rc = TS.query(S, s);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 3 );
        TS_ASSERT( tag_set_exists(S, "mammal") );
        TS_ASSERT( tag_set_exists(S, "spider") );  // fangs are teeth
        TS_ASSERT( tag_set_exists(S, "snake") );

        // for(tagd::tag_set::iterator it = S.begin(); it != S.end(); ++it) {
        //    std::cout << *it << std::endl;
        // }
    }

    void test_query_super_object(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        // TODO "what" is not actually used in the query
        // this will change over time, as different types
        // of interrogators will denote different queries
        tagd::interrogator q("what", "mammal");

        tagd::tag_set S;
        tagd_code ts_rc = TS.query(S, q);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 4 );
        TS_ASSERT( tag_set_exists(S, "dog") );
        TS_ASSERT( tag_set_exists(S, "cat") );
        TS_ASSERT( tag_set_exists(S, "whale") );
        TS_ASSERT( tag_set_exists(S, "bat") );
    }

	void test_query_parent_relation(void) {
        space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::interrogator q("what");
        q.relation("has", "blood", "warm");
        q.relation("can", "swim");

        tagd::tag_set S;
        tagd_code ts_rc = TS.query(S, q);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 1 );
        TS_ASSERT( tag_set_exists(S, "whale") );
	}

    void test_get_hard_tag(void) {
		space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag t;
        tagd_code ts_rc = TS.get(t, "_url");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
        TS_ASSERT_EQUALS( t.id(), "_url" )
	}

    void test_put_hard_tag(void) {
		space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag t("_caca", HARD_TAG_ENTITY);
        tagd_code ts_rc = TS.put(t);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_MISUSE");
	}

    void test_put_get_tag_super_relator(void) {
		space_type TS;
		TS.init(db_fname);
		populate_tags(TS);

		tagd::tag t1("husky", HARD_TAG_TYPE_OF, "dog");
		TS.put(t1);
		TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")

		tagd::abstract_tag t2;
		TS.get(t2, "husky");
		TS_ASSERT_EQUALS(TAGD_CODE_STRING(TS.code()), "TAGD_OK")
		TS_ASSERT_EQUALS( t2.super_relator() , HARD_TAG_TYPE_OF )
	}

    void test_relations(void) {
		space_type TS;
        TS.init(db_fname);
        populate_tags(TS);

        tagd::tag dog;
        tagd_code ts_rc = TS.get(dog, "dog");
        TS_ASSERT_EQUALS( dog.relations.size(), 3 )
		TS_ASSERT( dog.related("has", "legs", "4") )
		TS_ASSERT( dog.related("has", "tail")  )

        tagd::predicate_set how;
		TS_ASSERT_EQUALS( dog.related("bark", how), 1 )
		auto it = how.begin();
		TS_ASSERT( it != how.end() );
		if (it != how.end()) {
			TS_ASSERT_EQUALS( it->relator, "can" )
			TS_ASSERT_EQUALS( it->object, "bark" )
		}

		how.clear();
		TS_ASSERT_EQUALS( dog.related("legs", how), 1 )
		it = how.begin();
		TS_ASSERT( it != how.end() );
		if (it != how.end()) {
			TS_ASSERT_EQUALS( it->relator, "has" )
			TS_ASSERT_EQUALS( it->object, "legs" )
			TS_ASSERT_EQUALS( it->modifier, "4" )
		}

		TS_ASSERT( !dog.related("has", "fins") )
	}

/// URI TESTS ///

    void test_put_url(void) {
        space_type TS;
        tagd_code ts_rc = TS.init(db_fname);
        //tagd_code ts_rc = TS.init("test.db");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        populate_tags(TS);

        tagd::url a("http://www.hypermega.com/a/b/c?x=1&y=2#here");
        a.relation("about", "computer_security");
		TS_ASSERT_EQUALS(a.id(), "http://www.hypermega.com/a/b/c?x=1&y=2#here"); 
        ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
		TS_ASSERT_EQUALS(a.id(), "http://www.hypermega.com/a/b/c?x=1&y=2#here"); 

        tagd::url b;
        ts_rc = TS.get(b, a.id()); 
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
		TS_ASSERT_EQUALS(b.id(), "http://www.hypermega.com/a/b/c?x=1&y=2#here"); 
		TS_ASSERT_EQUALS(b.hduri(), "com:hypermega:www:/a/b/c:?x=1&y=2:here:http");
        TS_ASSERT( b.relations.size() > 1 )
        TS_ASSERT( b.related("about", "computer_security") )
        TS_ASSERT( b.related("has", HARD_TAG_SCHEME, "http") )
        TS_ASSERT( b.related("has", HARD_TAG_HOST, "www.hypermega.com") )
        TS_ASSERT( b.related("has", HARD_TAG_PRIV_LABEL, "hypermega") )
        TS_ASSERT( b.related("has", HARD_TAG_PUB, "com") )
        TS_ASSERT( b.related("has", HARD_TAG_SUB, "www") )
        TS_ASSERT( b.related("has", HARD_TAG_PATH, "/a/b/c") )
        TS_ASSERT( b.related("has", HARD_TAG_QUERY, "?x=1&y=2") )
        TS_ASSERT( b.related("has", HARD_TAG_FRAGMENT, "here") )
    }

    void test_get_hduri(void) {
        space_type TS;
        tagd_code ts_rc = TS.init(db_fname);
        //tagd_code ts_rc = TS.init("tagspace.db");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        populate_tags(TS);

        tagd::url a("http://www.hypermega.com/a/b/c?x=1&y=2#here");
        a.relation("about", "computer_security");
        ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        tagd::abstract_tag b;
        ts_rc = TS.get(b, a.hduri()); 
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
		TS_ASSERT_EQUALS(b.id(), "com:hypermega:www:/a/b/c:?x=1&y=2:here:http");
        TS_ASSERT_EQUALS( b.super_object() , HARD_TAG_URL )
        TS_ASSERT( b.related("about", "computer_security") )
        TS_ASSERT( b.related("has", HARD_TAG_SCHEME, "http") )
        TS_ASSERT( b.related("has", HARD_TAG_HOST, "www.hypermega.com") )
        TS_ASSERT( b.related("has", HARD_TAG_PRIV_LABEL, "hypermega") )
        TS_ASSERT( b.related("has", HARD_TAG_PUB, "com") )
        TS_ASSERT( b.related("has", HARD_TAG_SUB, "www") )
        TS_ASSERT( b.related("has", HARD_TAG_PATH, "/a/b/c") )
        TS_ASSERT( b.related("has", HARD_TAG_QUERY, "?x=1&y=2") )
        TS_ASSERT( b.related("has", HARD_TAG_FRAGMENT, "here") )
    }

    void test_query_url(void) {
        space_type TS;
		tagd_code ts_rc;
        TS.init(db_fname);
        // TS.init("tagspace.sqlite");
        populate_tags(TS);

        tagd::url a("http://en.wikipedia.org/wiki/Dog");
        a.relation("about", "dog");
        ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

		tagd::tag starwars("starwars", "movie");
		TS.put(starwars);
        tagd::url b("http://starwars.wikia.com/wiki/Dog");
        b.relation("about", "starwars");
        ts_rc = TS.put(b);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        tagd::url c("http://animal.discovery.com/tv-shows/dogs-101");
        c.relation("about", "dog");
        ts_rc = TS.put(c);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

        // TODO "what" is not actually used in the query
        tagd::interrogator q("what", "_url");
        q.relation("about", "dog");

        tagd::tag_set S;
        ts_rc = TS.query(S, q);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, "http://en.wikipedia.org/wiki/Dog") );
        TS_ASSERT( tag_set_exists(S, "http://animal.discovery.com/tv-shows/dogs-101") );

        S.clear();
        tagd::interrogator r("what", "_url");
        r.relation("has", "_path", "/wiki/Dog");
        ts_rc = TS.query(S, r);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 2 );
        TS_ASSERT( tag_set_exists(S, "http://en.wikipedia.org/wiki/Dog") );
        TS_ASSERT( tag_set_exists(S, "http://starwars.wikia.com/wiki/Dog") );

        // what is 'about' something
        tagd::interrogator what_about(HARD_TAG_INTERROGATOR);
        what_about.relation(tagd::make_predicate("about", ""));

        S.clear();
        ts_rc = TS.query(S, what_about);
        TS_ASSERT_EQUALS( TAGD_CODE_STRING(ts_rc), "TAGD_OK" );
        TS_ASSERT_EQUALS( S.size(), 3 );
        TS_ASSERT( tag_set_exists(S, "http://en.wikipedia.org/wiki/Dog") );
        TS_ASSERT( tag_set_exists(S, "http://starwars.wikia.com/wiki/Dog") );
        TS_ASSERT( tag_set_exists(S, "http://animal.discovery.com/tv-shows/dogs-101") );
    }

	void test_delete_url(void) {
        space_type TS;
		tagd_code ts_rc;
        TS.init(db_fname);
        // TS.init("tagspace.sqlite");
        populate_tags(TS);

        tagd::url a("http://en.wikipedia.org/wiki/Dog");
        a.relation("about", "dog");
        ts_rc = TS.put(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

		// delete relation
		ts_rc = TS.del(a);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

		tagd::url b;
        ts_rc = TS.get(b, "http://en.wikipedia.org/wiki/Dog");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");
		TS_ASSERT( !b.related("about", "dog") );

		// delete url	
        tagd::url c("http://en.wikipedia.org/wiki/Dog");
		ts_rc = TS.del(c);
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TAGD_OK");

		tagd::url d;
        ts_rc = TS.get(d, "http://en.wikipedia.org/wiki/Dog");
        TS_ASSERT_EQUALS(TAGD_CODE_STRING(ts_rc), "TS_NOT_FOUND");
    }

    void test_util(void) {
		std::string db_file = tagspace::util::user_db();
		TS_ASSERT( !db_file.empty() )
	}

//    void test_dump(void) {
//        space_type TS;
//        TS.init(db_fname);
//		std::cout << std::endl;
//        populate_tags(TS);
//		TS.dump();
//	}

//	void test_dump_terms(void) {
//        space_type TS;
//        TS.init(db_fname);
//		std::cout << std::endl;
//        populate_tags(TS);
//		TS.dump_terms();
//	}

};
